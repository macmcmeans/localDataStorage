/*                                                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                                       
lllllll                                                        lllllll DDDDDDDDDDDDD                                 tttt                               SSSSSSSSSSSSSSS      tttt                                                                                                      
l:::::l                                                        l:::::l D::::::::::::DDD                           ttt:::t                             SS:::::::::::::::S  ttt:::t                                                                                                      
l:::::l                                                        l:::::l D:::::::::::::::DD                         t:::::t                            S:::::SSSSSS::::::S  t:::::t                                                                                                      
l:::::l                                                        l:::::l DDD:::::DDDDD:::::D                        t:::::t                            S:::::S     SSSSSSS  t:::::t                                                                                                      
 l::::l    ooooooooooo       cccccccccccccccc  aaaaaaaaaaaaa    l::::l   D:::::D    D:::::D  aaaaaaaaaaaaa  ttttttt:::::ttttttt      aaaaaaaaaaaaa   S:::::S        ttttttt:::::ttttttt       ooooooooooo   rrrrr   rrrrrrrrr   aaaaaaaaaaaaa     ggggggggg   ggggg    eeeeeeeeeeee    
 l::::l  oo:::::::::::oo   cc:::::::::::::::c  a::::::::::::a   l::::l   D:::::D     D:::::D a::::::::::::a t:::::::::::::::::t      a::::::::::::a  S:::::S        t:::::::::::::::::t     oo:::::::::::oo r::::rrr:::::::::r  a::::::::::::a   g:::::::::ggg::::g  ee::::::::::::ee  
 l::::l o:::::::::::::::o c:::::::::::::::::c  aaaaaaaaa:::::a  l::::l   D:::::D     D:::::D aaaaaaaaa:::::at:::::::::::::::::t      aaaaaaaaa:::::a  S::::SSSS     t:::::::::::::::::t    o:::::::::::::::or:::::::::::::::::r aaaaaaaaa:::::a g:::::::::::::::::g e::::::eeeee:::::ee
 l::::l o:::::ooooo:::::oc:::::::cccccc:::::c           a::::a  l::::l   D:::::D     D:::::D          a::::atttttt:::::::tttttt               a::::a   SS::::::SSSSStttttt:::::::tttttt    o:::::ooooo:::::orr::::::rrrrr::::::r         a::::ag::::::ggggg::::::gge::::::e     e:::::e
 l::::l o::::o     o::::oc::::::c     ccccccc    aaaaaaa:::::a  l::::l   D:::::D     D:::::D   aaaaaaa:::::a      t:::::t              aaaaaaa:::::a     SSS::::::::SS    t:::::t          o::::o     o::::o r:::::r     r:::::r  aaaaaaa:::::ag:::::g     g:::::g e:::::::eeeee::::::e
 l::::l o::::o     o::::oc:::::c               aa::::::::::::a  l::::l   D:::::D     D:::::D aa::::::::::::a      t:::::t            aa::::::::::::a        SSSSSS::::S   t:::::t          o::::o     o::::o r:::::r     rrrrrrraa::::::::::::ag:::::g     g:::::g e:::::::::::::::::e 
 l::::l o::::o     o::::oc:::::c              a::::aaaa::::::a  l::::l   D:::::D     D:::::Da::::aaaa::::::a      t:::::t           a::::aaaa::::::a             S:::::S  t:::::t          o::::o     o::::o r:::::r           a::::aaaa::::::ag:::::g     g:::::g e::::::eeeeeeeeeee  
 l::::l o::::o     o::::oc::::::c     ccccccca::::a    a:::::a  l::::l   D:::::D    D:::::Da::::a    a:::::a      t:::::t    tttttta::::a    a:::::a             S:::::S  t:::::t    tttttto::::o     o::::o r:::::r          a::::a    a:::::ag::::::g    g:::::g e:::::::e           
l::::::lo:::::ooooo:::::oc:::::::cccccc:::::ca::::a    a:::::a l::::::lDDD:::::DDDDD:::::D a::::a    a:::::a      t::::::tttt:::::ta::::a    a:::::a SSSSSSS     S:::::S  t::::::tttt:::::to:::::ooooo:::::o r:::::r          a::::a    a:::::ag:::::::ggggg:::::g e::::::::e          
l::::::lo:::::::::::::::o c:::::::::::::::::ca:::::aaaa::::::a l::::::lD:::::::::::::::DD  a:::::aaaa::::::a      tt::::::::::::::ta:::::aaaa::::::a S::::::SSSSSS:::::S  tt::::::::::::::to:::::::::::::::o r:::::r          a:::::aaaa::::::a g::::::::::::::::g  e::::::::eeeeeeee  
l::::::l oo:::::::::::oo   cc:::::::::::::::c a::::::::::aa:::al::::::lD::::::::::::DDD     a::::::::::aa:::a       tt:::::::::::tt a::::::::::aa:::aS:::::::::::::::SS     tt:::::::::::tt oo:::::::::::oo  r:::::r           a::::::::::aa:::a gg::::::::::::::g   ee:::::::::::::e  
llllllll   ooooooooooo       cccccccccccccccc  aaaaaaaaaa  aaaallllllllDDDDDDDDDDDDD         aaaaaaaaaa  aaaa         ttttttttttt    aaaaaaaaaa  aaaa SSSSSSSSSSSSSSS         ttttttttttt     ooooooooooo    rrrrrrr            aaaaaaaaaa  aaaa   gggggggg::::::g     eeeeeeeeeeeeee  
                                                                                                                                                                                                                                                           g:::::g                     
                                                                                                                                                                                                                                               gggggg      g:::::g                     
                                                                                                                                                                                                                                               g:::::gg   gg:::::g                     
                                                                                                                                                                                                                                                g::::::ggg:::::::g                     
                                                                                                                                                                                                                                                 gg:::::::::::::g                      
                                                                                                                                                                                                                                                   ggg::::::ggg                        
                                                                                                                                                                                                                                                      gggggg                           
*/
/*///////////////////////////////////////////////////////////////////////////////////////////////////
localDataStorage 3.0.0
https://cdn.jsdelivr.net/gh/macmcmeans/localDataStorage@master/localDataStorage-3.0.0.js
/////////////////////////////////////////////////////////////////////////////////////////////////////
This version is
Copyright 2017 - 2022 William P. "Mac" McMeans
All rights reserved.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3. Neither the name of copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/////////////////////////////////////////////////////////////////////////////////////////////////////_setLengthProperty

/////////////////////////////////////////////////////////////////////////////////////////////////////
This version of localDataStorage incorporates aleaPRNG (a pseudo random number generator) by W. McMeans. 
/////////////////////////////////////////////////////////////////////////////////////////////////////
aleaPRNG 1.1
//////////////////////////////////////////////////////////////////
https://github.com/macmcmeans/aleaPRNG/blob/master/aleaPRNG-1.1.js
//////////////////////////////////////////////////////////////////
Original work copyright © 2010 Johannes Baagøe, under MIT license
This is a derivative work copyright (c) 2017-2020, W. Mac" McMeans, under BSD license.
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////
This version of localDataStorage incorporates fisherYatesDurstenfeldKnuthShuffle by W. McMeans. 
/////////////////////////////////////////////////////////////////////////////////////////////////////
fisherYatesDurstenfeldKnuthShuffle 1.2
//////////////////////////////////////////////////////////////////
https://github.com/macmcmeans/fisherYatesDurstenfeldKnuthShuffle/blob/master/fisherYatesDurstenfeldKnuthShuffle-1.2.js
//////////////////////////////////////////////////////////////////
Copyright © 2018, 2020, 2021 W. "Mac" McMeans
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
////////////////////////////////////////////////////////////////*/

const localDataStorage = function( _specifiedPrefix, _switches ) {
    return( function localDataStore( _storageKeyPrefix, _userswitches ) {
        "use strict";

        let
            // default scramble key
            _scrambleKey = { "this":['is'], "not":['cryptographic','strength'] }

            // user feedback mode
            , _weAreVerbose = 0

            // Broadcast Channel API
            , _broadcastChannel = 'localDataStorage'

            , ourAPIChannel
        ;

        ourAPIChannel = new BroadcastChannel( _broadcastChannel )

        const VERSION = '3.0.0'

            , ERROR_10 = "𝗡𝗼 𝘀𝗲𝗲𝗱 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            , ERROR_11 = "𝗡𝗼 𝗸𝗲𝘆 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            , ERROR_12 = "𝗡𝗼 𝗸𝗲𝘆 𝘃𝗮𝗹𝘂𝗲 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            , ERROR_13 = "𝗩𝗮𝗹𝘂𝗲 𝗶𝘀 𝗮𝗻 𝘂𝗻𝘀𝘂𝗽𝗽𝗼𝗿𝘁𝗲𝗱 𝘁𝘆𝗽𝗲"
            , ERROR_14 = "𝗡𝗼 𝘀𝗰𝗿𝗮𝗺𝗯𝗹𝗲 𝗸𝗲𝘆 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            , ERROR_15 = "𝗞𝗲𝘆 𝗱𝗼𝗲𝘀 𝗻𝗼𝘁 𝗲𝘅𝗶𝘀𝘁"
            , ERROR_16 = "𝗞𝗲𝘆 𝗺𝘂𝘀𝘁 𝗯𝗲 𝗮𝗻 𝗔𝗿𝗿𝗮𝘆 𝗞𝗲𝘆"
            , ERROR_17 = "𝗨𝗻𝗸𝗻𝗼𝘄𝗻 𝗱𝗮𝘁𝗮 𝘁𝘆𝗽𝗲"
            , ERROR_18 = "𝗡𝗼 𝗱𝗮𝘁𝗮 𝘁𝘆𝗽𝗲 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            , ERROR_19 = "𝗡𝗼 𝘃𝗮𝗹𝘂𝗲 𝘁𝗼 𝗰𝗼𝗻𝘃𝗲𝗿𝘁 𝗳𝗿𝗼𝗺"
            
            , ERROR_20 = "𝗡𝗼 𝘃𝗮𝗹𝘂𝗲 𝘁𝗼 𝗰𝗼𝗻𝘃𝗲𝗿𝘁 𝘁𝗼"
            , ERROR_21 = "𝗔𝗻 𝗲𝗿𝗿𝗼𝗿 𝗼𝗰𝗰𝘂𝗿𝗿𝗲𝗱 𝗿𝗲𝗮𝗱𝗶𝗻𝗴 𝗳𝗿𝗼𝗺 𝗹𝗼𝗰𝗮𝗹𝗦𝘁𝗼𝗿𝗮𝗴𝗲"
            , ERROR_22 = "𝗖𝗮𝗻𝗻𝗼𝘁 𝗮𝘀𝘀𝗶𝗴𝗻 𝘃𝗮𝗹𝘂𝗲 𝗯𝗲𝗰𝗮𝘂𝘀𝗲 𝗹𝗼𝗰𝗮𝗹𝗦𝘁𝗼𝗿𝗮𝗴𝗲 𝗾𝘂𝗼𝘁𝗮 𝗶𝘀 𝗳𝘂𝗹𝗹"
            , ERROR_23 = "𝗔𝗻 𝗲𝗿𝗿𝗼𝗿 𝗼𝗰𝗰𝘂𝗿𝗿𝗲𝗱 𝘄𝗿𝗶𝘁𝗶𝗻𝗴 𝘁𝗼 𝗹𝗼𝗰𝗮𝗹𝗦𝘁𝗼𝗿𝗮𝗴𝗲"
            , ERROR_24 = "𝗡𝗼 𝗶𝗻𝗱𝗲𝘅 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            , ERROR_25 = "𝗜𝗹𝗹𝗲𝗴𝗮𝗹 𝗶𝗻𝗱𝗲𝘅 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            , ERROR_26 = "𝗨𝗻𝗸𝗻𝗼𝘄𝗻 𝘀𝘁𝗿𝗶𝗻𝗴 𝗶𝗻𝗱𝗲𝘅 𝗸𝗲𝘆𝘄𝗼𝗿𝗱"
            , ERROR_27 = "𝗨𝗻𝗸𝗻𝗼𝘄𝗻 𝗻𝘂𝗺𝗲𝗿𝗶𝗰 𝗶𝗻𝗱𝗲𝘅"
            , ERROR_28 = "𝗨𝗻𝗸𝗻𝗼𝘄𝗻 𝗶𝗻𝗱𝗲𝘅" 
            , ERROR_29 = "𝗡𝗼 𝗻𝗲𝘄 𝗸𝗲𝘆 𝗻𝗮𝗺𝗲 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            
            , ERROR_30 = "𝗖𝗮𝗻𝗻𝗼𝘁 𝗿𝗲𝗻𝗮𝗺𝗲 𝗸𝗲𝘆 𝘁𝗼 𝗶𝘁𝘀 𝗼𝘄𝗻 𝗻𝗮𝗺𝗲"
            , ERROR_31 = "𝗗𝗲𝘀𝘁𝗶𝗻𝗮𝘁𝗶𝗼𝗻 𝗸𝗲𝘆 𝗮𝗹𝗿𝗲𝗮𝗱𝘆 𝗲𝘅𝗶𝘀𝘁𝘀"
            , ERROR_32 = "𝗡𝗼 𝘀𝘁𝗿𝗶𝗻𝗴 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            , ERROR_33 = "𝗡𝗼 𝘀𝗼𝘂𝗿𝗰𝗲 𝗸𝗲𝘆 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            , ERROR_34 = "𝗡𝗼 𝗱𝗲𝘀𝘁𝗶𝗻𝗮𝘁𝗶𝗼𝗻 𝗸𝗲𝘆 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            , ERROR_35 = "𝗦𝗼𝘂𝗿𝗰𝗲 𝗸𝗲𝘆 𝗱𝗼𝗲𝘀 𝗻𝗼𝘁 𝗲𝘅𝗶𝘀𝘁"
            , ERROR_36 = "𝗖𝗮𝗻𝗻𝗼𝘁 𝗼𝘃𝗲𝗿𝘄𝗿𝗶𝘁𝗲 𝗲𝘅𝗶𝘀𝘁𝗶𝗻𝗴 𝗱𝗲𝘀𝘁𝗶𝗻𝗮𝘁𝗶𝗼𝗻 𝗸𝗲𝘆"
            , ERROR_37 = "𝗗𝗮𝘁𝗮 𝘁𝘆𝗽𝗲 𝗺𝘂𝘀𝘁 𝗯𝗲 𝘀𝘁𝗿𝗶𝗻𝗴"
            , ERROR_38 = "𝗖𝗮𝗻𝗻𝗼𝘁 𝗰𝗼𝗽𝘆 𝗮𝗻 𝗼𝗯𝗳𝘂𝘀𝗰𝗮𝘁𝗲𝗱 𝗸𝗲𝘆"
            , ERROR_39 = "𝗞𝗲𝘆 𝗶𝘀 𝗻𝗼𝘁 𝗼𝗯𝗳𝘂𝘀𝗰𝗮𝘁𝗲𝗱"

            , ERROR_40 = "𝗕𝗮𝗰𝗸𝘂𝗽 𝗰𝗮𝗻𝗻𝗼𝘁 𝗼𝘃𝗲𝗿𝘄𝗿𝗶𝘁𝗲 𝗲𝘅𝗶𝘀𝘁𝗶𝗻𝗴 𝗹𝗼𝗰𝗮𝗹𝗦𝘁𝗼𝗿𝗮𝗴𝗲 𝗸𝗲𝘆"
            , ERROR_41 = "𝗥𝗲𝘀𝘁𝗼𝗿𝗲 𝗰𝗮𝗻𝗻𝗼𝘁 𝗼𝘃𝗲𝗿𝘄𝗿𝗶𝘁𝗲 𝗲𝘅𝗶𝘀𝘁𝗶𝗻𝗴 𝗺𝗲𝗺𝗼𝗿𝘆 𝗸𝗲𝘆"
            , ERROR_42 = "𝗦𝗼𝘂𝗿𝗰𝗲 𝗺𝗲𝗺𝗼𝗿𝘆 𝗸𝗲𝘆 𝗱𝗼𝗲𝘀 𝗻𝗼𝘁 𝗲𝘅𝗶𝘀𝘁"
            , ERROR_43 = "𝗦𝗼𝘂𝗿𝗰𝗲 𝗹𝗼𝗰𝗮𝗹𝗦𝘁𝗼𝗿𝗮𝗴𝗲 𝗸𝗲𝘆 𝗱𝗼𝗲𝘀 𝗻𝗼𝘁 𝗲𝘅𝗶𝘀𝘁"
            , ERROR_44 = "𝗡𝗼 𝗯𝗿𝗼𝗮𝗱𝗰𝗮𝘀𝘁 𝗰𝗵𝗮𝗻𝗻𝗲𝗹 𝘀𝗽𝗲𝗰𝗶𝗳𝗶𝗲𝗱"
            , ERROR_45 = "𝗕𝗮𝗰𝗸𝘂𝗽 𝗲𝗿𝗿𝗼𝗿: 𝗰𝗮𝗻𝗻𝗼𝘁 𝗼𝘃𝗲𝗿𝘄𝗿𝗶𝘁𝗲 𝗲𝘅𝗶𝘀𝘁𝗶𝗻𝗴 𝗸𝗲𝘆"
            , ERROR_46 = "𝗕𝗮𝗰𝗸𝘂𝗽 𝗲𝗿𝗿𝗼𝗿: 𝗰𝗮𝗻𝗻𝗼𝘁 𝗰𝗿𝗲𝗮𝘁𝗲 𝗻𝗲𝘄 𝗸𝗲𝘆"
            , ERROR_47 = "𝗥𝗲𝘀𝘁𝗼𝗿𝗲 𝗲𝗿𝗿𝗼𝗿: 𝗰𝗮𝗻𝗻𝗼𝘁 𝗼𝘃𝗲𝗿𝘄𝗿𝗶𝘁𝗲 𝗲𝘅𝗶𝘀𝘁𝗶𝗻𝗴 𝗸𝗲𝘆"
            , ERROR_48 = "𝗥𝗲𝘀𝘁𝗼𝗿𝗲 𝗲𝗿𝗿𝗼𝗿: 𝗰𝗮𝗻𝗻𝗼𝘁 𝗰𝗿𝗲𝗮𝘁𝗲 𝗻𝗲𝘄 𝗸𝗲𝘆"

            , SUPPORTED_TYPES = [ 'array', 'bigint', 'boolean', 'date', 'float', 'integer', 'null', 'number', 'object', 'string' ]

            // 1 byte overhead per flag (stored using 2 bytes)
            //////////////////////////////////////////////////
            , SHUFFLE_MARKER = String.fromCodePoint(  1 )

            , TYPE_OBFUSCATE = String.fromCodePoint(  2 )
            , TYPE_CRUNCH    = String.fromCodePoint(  3 )

            , TYPE_ARRAY     = String.fromCodePoint(  4 )
            , TYPE_BIGINT    = String.fromCodePoint(  5 )
            , TYPE_BOOLEAN   = String.fromCodePoint(  6 )
            , TYPE_DATE      = String.fromCodePoint(  7 )
            , TYPE_NUMBER    = String.fromCodePoint(  8 )
            , TYPE_OBJECT    = String.fromCodePoint(  9 )
            , TYPE_STRING    = String.fromCodePoint( 10 )

            //////////////////////////////////////////////////

            , STORAGE_TEST = '__storage_test__' 

            , CRUNCH_TEST  = '__crunch_test__' 

            , STRIP_THE_PREFIX = true

            , __prefix = function() {
                let _now = new Date();
                return _now.getTime() + ':' + ( Math.random() * 100000000 | 0 );
            }()

            , _prefix = _storageKeyPrefix === '' 
                ? '' 
                : typeof _storageKeyPrefix === 'undefined' 
                    ? __prefix 
                    : _storageKeyPrefix

            , _memoryKeyPrefix = '#'

            , __isStorageAvailable = function( _type ) { 
                let storage
                    , x = STORAGE_TEST
                ;

                try {
                    storage = window[ _type ]
                    storage.setItem( x, x );
                    storage.removeItem( x );
                    return true;
                }
                catch( e ) {
                    return false;
                }
            }

            , _storageIsAvailable = function() {
                _housekeeping();
                return __isStorageAvailable( 'localStorage' ); 
            }

            /*////////////////////////////////////////////////////////////////////
            aleaPRNG 1.1
            //////////////////////////////////////////////////////////////////////
            Copyright (c) 2017-2020, W. "Mac" McMeans
            LICENSE: BSD 3-Clause License
            https://github.com/macmcmeans/aleaPRNG/blob/master/aleaPRNG-1.1.min.js
            ////////////////////////////////////////////////////////////////////*/
            , _aleaPRNG = function() {
                return function(n) {
                    "use strict";
                    var a, u, i, c, r, t = new Uint32Array(3), f = "", e = "aleaPRNG 1.1";
                    function o(n) {
                        var o, r, t = (o = 4022871197, (r = function(n) {
                            n = n.toString();
                            for (var r = 0, t = n.length; r < t; r++) {
                                var e = .02519603282416938 * (o += n.charCodeAt(r));
                                e -= o = e >>> 0, o = (e *= o) >>> 0, o += 4294967296 * (e -= o);
                            }
                            return 2.3283064365386963e-10 * (o >>> 0);
                        }).version = "Mash 0.9", r);
                        a = t(" "), u = t(" "), i = t(" "), c = 1;
                        for (var e = 0; e < n.length; e++) (a -= t(n[e])) < 0 && (a += 1), (u -= t(n[e])) < 0 && (u += 1), 
                        (i -= t(n[e])) < 0 && (i += 1);
                        f = t.version, t = null;
                    }
                    function l(n) {
                        return parseInt(n, 10) === n;
                    }
                    var s = function() {
                        var n = 2091639 * a + 2.3283064365386963e-10 * c;
                        return a = u, u = i, i = n - (c = 0 | n);
                    };
                    return s.fract53 = function() {
                        return s() + 11102230246251565e-32 * (2097152 * s() | 0);
                    }, s.int32 = function() {
                        return 4294967296 * s();
                    }, s.cycle = function(n) {
                        (n = void 0 === n ? 1 : +n) < 1 && (n = 1);
                        for (var r = 0; r < n; r++) s();
                    }, s.range = function() {
                        var n, r;
                        return r = 1 === arguments.length ? arguments[n = 0] : (n = arguments[0], arguments[1]), 
                        arguments[0] > arguments[1] && (n = arguments[1], r = arguments[0]), l(n) && l(r) ? Math.floor(s() * (r - n + 1)) + n : s() * (r - n) + n;
                    }, s.restart = function() {
                        o(r);
                    }, s.seed = function() {
                        o(Array.prototype.slice.call(arguments));
                    }, s.version = function() {
                        return e;
                    }, s.versions = function() {
                        return e + ", " + f;
                    }, 0 === n.length && (window.crypto.getRandomValues(t), n = [ t[0], t[1], t[2] ]), 
                    o(r = n), s;
                }(Array.prototype.slice.call(arguments));
            }

            // return boolean true/false testing for array equality and identity
            , _arraysAreEqual = function( a1, a2, ) {
                let _return = false
                    , _test = true
                ;

                if( a1.length === a2.length ) {
                    for( let i = 0; i < a1.length; i++ ) {
                        _test = a2.indexOf( a1[ i ] ) !== -1;
                        if( _test !== true ) { break; }
                    }
                    _return = _test;
                }  

                return _return;
            }

            //////////////////////////////////////////////////////////////////////

            /*////////////////////////////////////////////////////////////////////
            customRadix 1.1.0
            //////////////////////////////////////////////////////////////////////
            Copyright (c) 2017, W. "Mac" McMeans
            LICENSE: BSD 3-Clause License
            ////////////////////////////////////////////////////////////////////*/
            , _customRadix = function() {
                "use strict";
                const e = "0123456789", r = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", t = "abcdefghijklmnopqrstuvwxyz", n = "+/!#$%&()*,-:;<=>?@[]^_`{|}~\\. '\"", o = e + r + t + n + "¡¢£¤¥¦§¨©ª«¬®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿĆćĈĉĊċČčĜĝĞğĠġĢģĤĥĦħĲĳĴĵĶķĸĹĺĻļĽľĿŀŁłŊŋŔŕŖŗŘřŜŝŞşŠšŢţŤťŦŧŲųŴŵŶŷŸŹźŻżŽžΔΛΣΓ", i = "./" + e + r + t, a = function(e) {
                    return function(e) {
                        function r(r) {
                            var a = r;
                            if (r < 10) throw new Error("Specified seed must be greater than 9");
                            t = (a += "").length, n = "";
                            for (var s = 0; s < t; s++) n += a[t - s - 1];
                            "string" == typeof e && (t = 2 * (t + 1)), o = +("0." + n), i = +("0." + t);
                            for (var f = 0; f < 20; f++) o = ((i += o) * o + i) % 1;
                        }
                        var t, n, o, i, a = new Date().getTime();
                        r(e || a);
                        var s = function() {
                            return o = ((i += o) * o + i) % 1;
                        };
                        return s.seed = function(e) {
                            r(e);
                        }, s;
                    }(e);
                }, s = function(e) {
                    var r, t;
                    if (void 0 === e) r = i; else if ("number" == typeof e) {
                        if (e < 2) throw new Error("Glyph set must contain at least 2 graphemes");
                        r = o.slice(0, e);
                    } else if (e instanceof Array) {
                        if (e = Number(e[0]), "number" == typeof (t = e) && 0 != t && !t) throw new Error("Array must be number");
                        if (e < 2) throw new Error("Glyph set must contain at least 2 graphemes");
                        r = (r = f(o, e)).slice(0, e);
                    } else if ("BASE64" === e.toUpperCase()) r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; else if ("B64" === e.toUpperCase()) r = i; else if ("UUENCODE" === e.toUpperCase()) r = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"; else if ("XXENCODE" === e.toUpperCase()) r = "+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; else if ("BINHEX" === e.toUpperCase()) r = "!\"#$%&'()*+,-0123456789@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr"; else if ("7BIT" === e.toUpperCase()) r = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/!#$%&()*,-:;<=>?@[]^_`{|}~\\. '\""; else if ("FPN" === e.toUpperCase()) r = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/!#$%&()*,-:;<=>?@[]^_`{|}~\\"; else {
                        if (e.length < 2) throw new Error("Glyph set must contain at least 2 graphemes");
                        if (u(e)) throw new Error("Glyph set contains duplicate graphemes");
                        r = e;
                    }
                    return r;
                }, f = function(e, r) {
                    var t, n, o, i;
                    return i = .059886774281039834 * (o = r), i += 21845.33332824707, i -= o = 0 | i, 
                    o = 0 | (i *= o), t = (o ^= 4294967296 * (i -= o)) >>> 0, n = a(t), function(e, r) {
                        var t, n = e.length;
                        for (r = r || function() {
                            var e = new Uint32Array(2);
                            return window.crypto.getRandomValues(e), parseFloat("0." + e[0] + e[1]);
                        }; --n; ) e[t = Math.floor(r() * (n + 1))] = [ e[n], e[n] = e[t] ][0];
                    }(e = e.split(""), n), e.join("");
                }, u = function(e) {
                    for (var r = e.length, t = 0; t < r; t++) for (var n = e[t], o = t + 1; o <= r - 1; o++) if (n === e[o]) return !0;
                    return !1;
                }, p = function(e, r, t) {
                    var n, o = s(r), i = o.length, a = Math.floor(e), u = "";
                    for (void 0 !== t && (o = f(o, t)); n = a % i, u = o.charAt(n) + u, 0 !== (a = Math.floor(a / i)); ) ;
                    return u;
                }, l = function(e, r, t) {
                    var n = s(r), o = n.length, i = 0;
                    void 0 !== t && (n = f(n, t));
                    for (var a = 0; a < e.length; a++) i = i * o + n.indexOf(e[a]);
                    return i;
                };
                return {
                    base10ToRadix: function(e, r, t) {
                        if (e !== parseInt(e, 10) && "fpn" !== r.toLowerCase()) throw new Error("Number must be positive integer in Base-10");
                        if (void 0 !== t && "number" != typeof t) throw new Error("Scramble key must be a number");
                        if ("fpn" === r.toLowerCase() && (e + "").includes(".")) {
                            let r = (e + "").split("."), n = p(+r[0], "fpn", t), o = p(+r[1], "fpn", t), i = "";
                            return "0" === (r[1] + "").substr(0, 1) && (i = " "), n + "." + i + o;
                        }
                        return p(e, r, t);
                    },
                    changeRadix: function(e, r, t, n) {
                        var o = this.radixToBase10(e, r, n);
                        return this.base10ToRadix(o, t, n);
                    },
                    radixToBase10: function(e, r, t) {
                        if (void 0 !== t && "number" != typeof t) throw new Error("Scramble key must be a number");
                        if ("fpn" === r.toLowerCase() && e.includes(".")) {
                            let r = e.split("."), n = l(r[0], "fpn", t) + "", o = "";
                            return r[1].includes(" ") ? (r[1] = r[1].replace(" ", ""), o = "0" + l(r[1], "fpn", t)) : o = l(r[1], "fpn", t) + "", 
                            +(n + "." + o);
                        }
                        return l(e, r, t);
                    },
                    version: function() {
                        return "customRadix v1.1.0";
                    }
                }
            }()
            /////////////////////////////////////////////////////////////////////

            // compute internal hash (checksum)
            , __checksum = function() {
                const _mm =
                    function() {
                        var r = 4022871197;
                        return function(n) {
                            n = n.toString();
                            for (var t = 0, a = n.length; t < a; t++) {
                                r += n.charCodeAt(t);
                                var e = .02519603282416938 * r;
                                r = e >>> 0, e -= r, e *= r, r = e >>> 0, e -= r, r += 4294967296 * e;
                            }
                            return 2.3283064365386963e-10 * (r >>> 0);
                        };
                    }
                ;

                let _x1   = localDataStore.toString()
                    , _x2 = _mm()
                    , _x3 = _x2( _x1 ) + ''
                ;
                _x3 = _x3.replace( '0.', '' );
                _x3 = +_x3;
                return _x3;
            }()

            , _checksum = __checksum
            //////////////////////////////////////////////////////////////////////

            // convert a localStorage string into its original primitive object (Number, Date, String, etc.) based on embedded flags
            // markers are at the end of the value
            , _convertFromString = function( _value ) {
                let _recovered_value = ''
                    , _recoveredType
                ;
                const thisIsOurType  = function( type ) {
                        return ( _value.substr( -1, 1 ) === type ); 
                    }
                    , extractTheData = function( val )  {
                        return val.substr( 0, val.length - 1 );
                    }
                    , parseTheData   = function( val )  {
                        return JSON.parse( val, _JSONparser );
                    }
                    , anyOfThese = function() {
                        let tally = arguments.length
                            , items = Object.values( arguments )
                        ;
                        
                        let obj = {
                            areIn( source ) {
                                for( let i = 0; i < tally; i++ ) { if( items[ i ] === source ) { return true; } }
                                return false;
                            }
                            , total() { return tally; }
                        };

                        return obj;
                    }
                ;


                if( 'undefined' === typeof _value ) { throw new Error( ERROR_19 ); }

                // check for embedded flags (at end of string)
                if( anyOfThese( TYPE_ARRAY, TYPE_BIGINT, TYPE_BOOLEAN, TYPE_DATE, TYPE_NUMBER, TYPE_OBJECT, TYPE_CRUNCH, TYPE_STRING ).areIn( _value.substr( -1, 1 ) ) ){

                    if( _recovered_value === '' ) {
                        _recoveredType = TYPE_CRUNCH;
                        if( thisIsOurType( _recoveredType ) ) {
                            _value = extractTheData( _value );
                            _value = _uncrunch( _value );
                            _recovered_value = _value;
                        }
                    }
                    if( _recovered_value === '' ) {
                        _recoveredType = TYPE_STRING;
                        if( thisIsOurType( _recoveredType ) ) {
                            _value = extractTheData( _value );
                            _recovered_value = _value;
                        }
                    }
                    if( _recovered_value === '' ) {
                        _recoveredType = TYPE_DATE;
                        if( thisIsOurType( _recoveredType ) ) {
                            _value = extractTheData( _value );
                            //_recovered_value = parseTheData( _value );
                            _recovered_value = _customRadix.radixToBase10( _value, '7BIT' );
                            _recovered_value = new Date( _recovered_value );
                        } 
                    }
                    if( _recovered_value === '' ) {
                        _recoveredType = TYPE_ARRAY;
                        if( thisIsOurType( _recoveredType ) ) {
                            _value = extractTheData( _value );
                            _recovered_value = parseTheData( _value );
                        } 
                    }
                    if( _recovered_value === '' ) {
                        _recoveredType = TYPE_NUMBER;
                        if( thisIsOurType( _recoveredType ) ) {
                            _value = extractTheData( _value );
                            _recovered_value = _customRadix.radixToBase10( _value, 'FPN' );
                            //_recovered_value = parseFloat( _recovered_value );    // ints and floats
                            //_recovered_value = parseFloat( _value );    // ints and floats
                        }
                    }
                    if( _recovered_value === '' ) {
                        _recoveredType = TYPE_BOOLEAN;
                        if( thisIsOurType( _recoveredType ) ) {
                            _value = extractTheData( _value );
                            _recovered_value = _value === '1' ? true : false;
                        }
                    }
                    if( _recovered_value === '' ) {
                        _recoveredType = TYPE_BIGINT;
                        if( thisIsOurType( _recoveredType ) ) {
                            _value = extractTheData( _value );
                            _recovered_value = BigInt( _value );
                        }
                    }
                    if( _recovered_value === '' ) {
                        _recoveredType = TYPE_OBJECT;
                        if( thisIsOurType( _recoveredType ) ) {
                            _value = extractTheData( _value );
                            _recovered_value = parseTheData( _value );
                        }
                    }

                } else {

                    if( _getTypeOfKey( 'VALUE_OVERRIDE', _value ) === 'presumed bigint' ) {
                        _value = _value.substring( 0, _value.length - 1 );
                        _recovered_value = BigInt( _value );
                    
                    } else

                    // assume it's an object, or an array, that has been stringified, if possible
                    if( _value[ 0 ] === "{" || _value[ 0 ] === "[" ) {
                        try{
                            _recovered_value = parseTheData( _value );
                        } catch( e ) {
                            _recovered_value = _value;
                        }

                    // assume it's a typical localStorage string
                    } else {
                        
                        // is it a possible number (int or float)?
                        if( _value == +_value ) {
                            _recovered_value = +_value;

                        // nope, just a regular key value (string)
                        } else {
                            _recovered_value = _value;
                        }
                    }
                }

                return _recovered_value;
            }

            // convert a primitive object (Number, Date, String, etc.) to localStorage string
            // embeds data type flags for reconstruction
            // marker flags are 1 byte each, adding 2 bytes (actual memory used) overhead for each data type stored
            // returns the converted object and its data type
            , _convertToString = function( value ) {
                let _marker = ''
                    , _type = ''
                    , _temp
                    , cr1
                    , cr2
                ;

                if( 'undefined' === typeof value ) { throw new Error( ERROR_20 ); }

                // strings
                if( 'string' === typeof value ) {
                    _type = 'string';
                    _marker = TYPE_STRING;

                    // only try to compress strings
                    if( _isCrunchable( value ) ) {
                        _type = 'compressed string';

                        value = _crunch( value );
                        //value = TYPE_CRUNCH + value; 
                        _marker = TYPE_CRUNCH;

                    }
                
                } else
                
                // dates
                if( 'object' === typeof value && value instanceof Date  ) { 
                    _type = 'date';
                    _marker = TYPE_DATE;
                    
                    // integrity check
                    //_temp = +value;
                    //cr1 = _customRadix.base10ToRadix( _temp, '7bit' );
                    //cr2 = _customRadix.radixToBase10( cr1,   '7bit' );
                    //if( cr2 === _temp ) {
                    //    value = _temp;
                    //} else {
                    //    value = JSON.stringify( value, _JSONstringer );
                    //}
                    value = +value;
                    value = _customRadix.base10ToRadix( value, '7BIT' );

                } else

                // arrays
                if( 'object' === typeof value && value instanceof Array ) { 
                    _type = 'array';
                    _marker = TYPE_ARRAY;
                    value = JSON.stringify( value, _JSONstringer );

                } else

                // numbers
                if( 'number' === typeof value ) {
                    _type = 'integer';
                    if( ( value + '' ).indexOf( '.' ) !== -1 ) { _type = 'float'; }

                    _marker = TYPE_NUMBER;
                    value = _customRadix.base10ToRadix( value, 'FPN' );
                    //value += '';

                } else

                // booleans
                if( 'boolean' === typeof value ) {
                    _type = 'boolean';
                    _marker = TYPE_BOOLEAN;

                    value = Number( value );
                    value += '';

                } else

                // bigints
                if( 'bigint' === typeof value ) {
                    _type = 'bigint';
                    _marker = TYPE_BIGINT;

                    value += '';

                } else

                // all other objects (null etc.)
                if( 'object' === typeof value ) {
                    _type = 'object';
                    
                    if( value === null ) { _type = 'null'; }

                    _marker = TYPE_OBJECT;
                    value = JSON.stringify( value, _JSONstringer );
                }

                if( _marker !== '' ) {
                    value += _marker;
                }

                return [ value, _type ];
            }

            // compress simple 7-bit ASCII words
            , _crunch = function( _text ) {
                return _smidge.compress( _text );
            }

            // wrapper for localStorage removeItem method
            , _deleteLocalStorage = function( key ) {
                localStorage.removeItem( key );
            }

            // friendly formatted output
            , _describeSize = function( _val, _1k = false ) {
                const _units = [ "bytes", "KB", "MB" ];
                let _sizeUnit = 0
                    , k = 1024
                ;

                if( _1k ) { k = 1000; }

                while( _val > k ) { _sizeUnit++; _val /= k; }
                _val = _val == 1 
                    ? '1 byte' 
                    : _val.toFixed( 2 ) + " " + _units[ _sizeUnit ];
                _val = _val.replace( '.00 ', ' ' );

                return _val;
            }

            // in-place array shuffle (no copy made)
            , _fisherYatesDurstenfeldKnuthShuffle = function(n, r) {
                var t, e = n.length;
                for (r = r || a; --e; ) t = Math.floor(r() * (e + 1)), n[t] = [ n[e], n[e] = n[t] ][0];
            }

            // shuffled array is copied to the restored (unshuffled) array
            , _fisherYatesDurstenfeldKnuthUnshuffle = function(r, e) {
                for (var n, f = new Array(r.length), t = new Array(r.length), a = r.length, h = 0; h < a; h++) t[h] = h;
                for (var h = a - 1; h > 0; h--) n = Math.floor(e() * (h + 1)), t[h] = [ t[n], t[n] = t[h] ][0];
                for (var h = 0; h < a; h++) f[t[h]] = r[h];
                return f;
            }

            // A fast Hash for integer or float. Returns positive integer.
            , _foldFPHash = function(n) {
                let r = .059886774281039834 * n;
                return r += 21845.33332824707, n = 0 | r, r -= n, r *= n, n = 0 | r, r -= n, (n ^= 4294967296 * r) >>> 0;
            }

            // return key's primitive value
            , _get = function( key ) {
                if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }

                let _value = _readLocalStorage( key );
        
                if( !_value ) {
                    return undefined;
                } else {
                    return _convertFromString( _value );        
                }
            }

            // returns unsorted array of prefixed key names in store, by default
            // optionally, prefixes may be stripped
            , _getAllKeysThisInstance = function( stripKeyPrefix = false ) {
                let _key
                    , _prefix           = _getKeyPrefix()
                    , _keysThisInstance = new Array()
                    , _len              = localStorage.length
                ;

                // loop through all localStorage keys
                for( let i = _len; i--; ) {
                    _key = localStorage.key( i );

                    // get the ones prefixed for this instance
                    if( _key.substr( 0, _prefix.length ) === _prefix ) {
                        
                        // check if the key prefix should be retained
                        if( stripKeyPrefix ) {
                            _key = _stripPrefix( _key );
                        }

                        // add keyname to list of keys 
                        _keysThisInstance.push( _key );
                    }
                }

                return _keysThisInstance;
            }

            , _getAllMemoryKeysThisInstance = function( stripKeyPrefix = false ) {
                let _memoryKeysThisInstance = new Array();

                for( let key in lds ) {
                    if( key.substr( 0, 1 ) === '#' ) {
                        
                        // check if the key prefix should be retained
                        if( stripKeyPrefix ) { key = _stripMemKeyPrefix( key ); }

                        // add keyname to list of keys 
                        _memoryKeysThisInstance.push( key );
                    }
                }
                return _memoryKeysThisInstance;
            }

            // returns count of bytes in string
            , _getByteCount = function( t ) {
                t = "" + t;
                for (var r = t.length, n = r - 1; n >= 0; n--) {
                    let e = t.charCodeAt(n);
                    e > 127 && 2047 >= e ? r++ : e > 2047 && 65535 >= e && (r += 2), e >= 56320 && 57343 >= e && n--;
                }
                return r;
            }

            // returns count of codepoints in string
            , _getCodePointCount = function( t ) {
                return t = "" + t, __ucs2decode( t ).length;
            }

            // create an object listing duplicate values, their associated keys, and counts
            , _getDuplicates = function( _weShouldSortThis ) {
                let dupes = _showDupes()
                    , _keyNamesObj = {}
                    , _keyNames    = {}
                    , _tempKey     = ''
                    , _len         = localStorage.length
                ;

                if( _weShouldSortThis ) { _naturalSort( dupes ); }

                if( dupes.length ) {
                
                    for( let ii = 0, len = dupes.length; ii < len; ii++ ) {
                        let _keyNameParts = new Array();

                        for( let i = _len; i--; ) {
                            _tempKey = localStorage.key( i );

                            if( JSON.stringify( _get( _tempKey ), _JSONstringer ) === JSON.stringify( dupes[ ii ], _JSONstringer ) ) {
                                _tempKey = _stripPrefix( _tempKey );
                                _keyNameParts.push( _tempKey );
                            }
                        }

                        if( _weShouldSortThis ) { _naturalSort( _keyNameParts ); }

                        _keyNames[ ii ] = { 
                            'value'      : dupes[ ii ]
                            , 'keys'     : _keyNameParts
                            , 'keycount' : _keyNameParts.length
                        }
                    }
                }

                _keyNamesObj = {
                    'dupecount' : dupes.length
                    , 'dupes'   : _keyNames 
                }

                return _keyNamesObj;
            }

            // return a JSON showing library internals
            , _getIdentity = function() {
                if( !_storageIsAvailable() ) { return false; }

                const _internals = {};

                _internals.version    = lds.version;
                _internals.checksum   = _checksum;
                _internals.prefix     = _prefix;
                _internals.quota      = lds.quota;
                _internals.bytes_used = lds.showquotaused( true );
                _internals.channel    = lds.channel;

                return { 'localDataStorage' : _internals };
            }

            // retrieve the prefix defined when LDS was instantiated
            , _getKeyPrefix = function() {
                return _prefix + '.';
            }

            , _getMemoryKeyType = function( key ) {
                return _getTypeOfMemoryKey( _readMemoryKey( key ) );
            }

            // convert input to integer based on value and data type
            // returns [ integer, objectString ]
            , _getNumberFromObject = function( _input ) {
                if( 'undefined' === typeof _input ) { return; }

                let _json = typeof _input === 'bigint' 
                    ? _input.toString() 
                    : JSON.stringify( _input, _JSONstringer )
                    
                    , _num     = 0
                    , _type    = ''
                    , _convert = ''
                ;
                const _reverseIt = function( _string ) { 
                        return Array.from( _string ).reverse().join( '' ); 
                    }
                    , _hashCode = function( _string ) {
                        let _rng = _xmur3a( _string );
                        return _rng();
                    }
                ;
                
                // arrays
                if( _input instanceof Array ) { 
                    _type = 'ARRAY1';

                } else

                // bigints
                if( 'bigint' === typeof _input ) {
                    _type = 'BIGINT2'

                } else

                // booleans
                if( 'boolean' === typeof _input ) {
                    _type = 'BOOLEAN4';

                } else

                // dates
                if( _input instanceof Date ) { 
                    _type = 'DATE8';

                } else

                // numbers
                if( 'number' === typeof _input ) {
                    if( ( _input + '' ).includes( '.' ) ) {
                        _type = 'FLOAT16';
                    } else {
                        _type = 'INTEGER32';
                    }

                } else

                // strings
                if( 'string' === typeof _input ) {
                    _type = 'STRING64'

                // other objects
                } else {
                    _type = 'OBJECT128';
                }

                // may need canonical JSON stringify in the future (https://github.com/mirkokiefer/canonical-json)
                _convert = ( 
                    _json              + 
                    _json.length       + 
                    _type              +
                    _hashCode( _json ) +
                    _hashCode( _reverseIt( _json ) ) 
                );

                for( let i = 0; i < _convert.length; i++ ) {
                    _num += _convert.codePointAt( i );
                }

                return [ _num, _convert ];
            }

            // return key with prefix
            , _getPrefixedKey = function( key ) {
                return _getKeyPrefix() + key;
            }

            // find all duplicate key values in _array (strict check; match value and type)
            , _getStrictDuplicates = function( _array ) {
                let _dupes = new Array()
                    , _tempDupe = new Array()
                    , _len = _array.length
                ;

                for( let i = 0; i < _len; i++ ) {
                    _tempDupe = _array[ i ]; // unconverted localStorage string (much easier to check)

                    if( ( _array.lastIndexOf( _tempDupe ) !== i ) && ( _dupes.indexOf( _tempDupe ) === -1 ) ) {
                        _dupes.push( _tempDupe );
                    }
                }

                return _dupes;
            }

            // return the primitive value of the prefixed key
            , _getTheKey = function( _key ) {
                return _get( _getPrefixedKey( _key ) );
            }

            // return the data type of value
            , _getTypeOf = function( value ) {
                return _convertToString( value )[ 1 ];
            }

            // return the primitive data type of the key's value
            // when valueToCheck is supplied, no key  lookup is performed
            , _getTypeOfKey = function( key, valueToCheck ) {
                if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }

                let _recoveredType = ''
                    , _value = ''
                ;
                const thisIsOurType = function( type ) { 
                        return _value.includes( type ); 
                    }
                    , anyOfThese = function() {
                        let tally = arguments.length
                            , items = Object.values( arguments )
                        ;
                        
                        let obj = {
                            areIn( source ) {
                                for( let i = 0; i < tally; i++ ) { if( items[ i ] === source ) { return true; } }
                                return false;
                            }
                            , total() { return tally; }
                        };

                        return obj;
                    }
                ;

                // check the type from the value of the key
                if( 'undefined' === typeof valueToCheck ) {

                    if( _haskey( key ) ) {
                        _value = _readLocalStorage( key );
                    } else {
                        return undefined;
                    }

                // check the type from the supplied value
                } else {
                    _value = valueToCheck;
                }

                // check for embedded flags (at end of string)
                if( anyOfThese( TYPE_ARRAY, TYPE_BIGINT, TYPE_BOOLEAN, TYPE_DATE, TYPE_NUMBER, TYPE_OBJECT, TYPE_CRUNCH, TYPE_STRING ).areIn( _value.substr( -1, 1 ) ) ) {
                   
                    if( thisIsOurType( TYPE_CRUNCH ) ) {
                        _recoveredType = 'compressed string';
                    }
                    if( _recoveredType === '' ) {
                        if( thisIsOurType( TYPE_STRING ) ) {
                            _recoveredType = 'string';
                        } 
                    }
                    if( _recoveredType === '' ) {
                        if( thisIsOurType( TYPE_DATE ) ) {
                            _recoveredType = 'date';
                        } 
                    }
                    if( _recoveredType === '' ) {
                        if( thisIsOurType( TYPE_ARRAY ) ) {
                            _recoveredType = 'array';
                        } 
                    }
                    if( _recoveredType === '' ) {
                        if( thisIsOurType( TYPE_NUMBER ) ) {
                            _recoveredType = 'number';

                            if( _value.includes( '.' ) ) {
                                _recoveredType = 'float';
                            } else {
                                _recoveredType = 'integer';
                            }
                        }
                    }
                    if( _recoveredType === '' ) {
                        if( thisIsOurType( TYPE_BOOLEAN ) ) {
                            _recoveredType = 'boolean';
                        }
                    }
                    if( _recoveredType === '' ) {
                        if( thisIsOurType( TYPE_BIGINT ) ) {
                            _recoveredType = 'bigint';
                        }
                    }
                    if( _recoveredType === '' ) {
                        if( thisIsOurType( TYPE_OBJECT ) ) {
                            _recoveredType = 'object';

                            if( _value[ 0 ] + _value[ 1 ] + _value[ 2 ] + _value[ 3 ] === 'null' ) {
                                _recoveredType = 'null';
                            }
                        }
                    }

                
                // there are no embedded flags
                } else {

                    // assume it's an object, or an array, that has been stringified, if possible
                    if( _value[ 0 ] === "[" ) {
                        _recoveredType = 'presumed array';

                    } else
                    if( _value[ 0 ] === "{" ) {
                        _recoveredType = 'presumed object';

                    // assume it's a typical localStorage string
                    } else {

                        // is it a bigint?
                        if( _value.substr( -1, 1 ) === 'n' && parseInt( _value, 10 ) === +( _value.substring( 0, _value.length - 1 ) ) ) {
                            _recoveredType = 'presumed bigint';
                        } else

                        // is it a possible number (int or float)?
                        if( _value == +_value ) {
                            _recoveredType = 'presumed number';

                        // nope, just a regular key value
                        } else {

                            // ensure we are working with a key, not a specified value
                            if( key !== null ) {
                                // can we unscramble it using the current global scramble key?
                                _value = _xorString(       _value, _scrambleKey, key.replace( _getKeyPrefix(), '' ) );              
                                _value = _unshuffleString( _value, _scrambleKey, key.replace( _getKeyPrefix(), '' ) );
                            } 


                            if( thisIsOurType( TYPE_STRING  ) ) {
                                _recoveredType = 'obfuscated string';
                            
                            } else
                            if( thisIsOurType( TYPE_BIGINT  ) ) {
                                _recoveredType = 'obfuscated bigint';

                            } else
                            if( thisIsOurType( TYPE_DATE    ) ) {
                                _recoveredType = 'obfuscated date';

                            } else
                            if( thisIsOurType( TYPE_ARRAY   ) ) {
                                _recoveredType = 'obfuscated array';

                            } else
                            if( thisIsOurType( TYPE_NUMBER  ) ) {
                                _recoveredType = 'obfuscated number';

                                if( _value.includes( '.' ) ) {
                                    _recoveredType = 'obfuscated float';
                                } else {
                                    _recoveredType = 'obfuscated integer';
                                }

                            } else
                            if( thisIsOurType( TYPE_BOOLEAN ) ) {
                                _recoveredType = 'obfuscated boolean';

                            } else
                            if( thisIsOurType( TYPE_OBJECT  ) ) {
                                _recoveredType = 'obfuscated object';
                        
                            // nope...
                            } else {
                                _recoveredType = 'presumed string';
                            }
                        }
                    }
                }

                return _recoveredType;
            }

            , _getTypeOfMemoryKey = function( value ) {
                let _recoveredType = ''
                    , _type = typeof value
                ;

                if( _type === 'string' ) {
                    _recoveredType = 'string';

                    if( value.includes( TYPE_CRUNCH ) ) {
                        _recoveredType = 'compressed string';
                    }
                }
                if( _recoveredType === '' && _type === 'number'  ) {

                    if( ( value + '' ).includes( '.' ) ) {
                        _recoveredType = 'float';
                    } else {
                        _recoveredType = 'integer';
                    }

                }
                if( _recoveredType === '' && _type === 'boolean' ) {
                    _recoveredType = 'boolean';
                }
                if( _recoveredType === '' && _type === 'bigint'  ) {
                    _recoveredType = 'bigint';
                }
                if( _recoveredType === '' && _type === 'object'  ) {
                        
                        if( value instanceof Array  ) {
                            _recoveredType = 'array';
                        
                        } else        
                        if( value instanceof Date   ) {
                            _recoveredType = 'date';
                        
                        } else        
                        if( value === null          ) {
                            _recoveredType = 'null';

                        } else {
                            _recoveredType = 'object';
                        } 

                } else
                if( _recoveredType === '' ) {
                    _recoveredType = 'unknown';
                }

                return _recoveredType;
            }


            // boolean test whether key exists
            , _haskey = function( key ) {
                return _readLocalStorage( key ) !== null ? true : false;
            }

            // boolean test whether value exists
            , _hasval = function( value ) {
                let _val = JSON.stringify( value, _JSONstringer )
                    , _test   = ''
                    , _key    = ''
                    , _return = false
                    , _len    = localStorage.length
                ;

                // loop through all localStorage keys and only check the ones prefixed for this instance
                for( let i = _len; i--; ) {
                    _key = localStorage.key( i );

                    if( _key.includes( _getKeyPrefix() ) ) {
                        _test = JSON.stringify( _get( _key ), _JSONstringer );
                        if( _val === _test ) {
                            _return = true;
                            break;
                        }
                    }
                }

                return _return;
            }

            // performed in every method
            , _housekeeping = function() {
                 lds.version = 'localDataStorage ' + VERSION;
                 lds.channel = _broadcastChannel;
            }

            // boolean check
            // determine if _text safely compresses, if it compresses to a smaller size, and
            // whether the smaller size (plus the marker) is worth the OP
            // the marker flag (like the others) is 2 bytes (stored as 4 bytes)
            , _isCrunchable = function( _text ) {
                let _crunchable   = false
                    , _withinSize = false
                    , _margin     = 0
                    , _compTxt    = _smidge.compress( _text ) + TYPE_CRUNCH
                    , _decompTxt  = _convertFromString( _compTxt )
                 ;

                _crunchable = ( ( _text === _decompTxt ) ? true : false );
                _withinSize = ( _getByteCount( _compTxt ) + _margin <= _getByteCount( _text + TYPE_STRING ) ? true : false );

                if( _crunchable && _withinSize ) {
                    return true;
                } else {
                    return false;
                }
            }

            // handles parsing bigint
            , _JSONparser = function( name, val ) {
                if( 'string' === typeof val ) {
                    if(
                        val.substr( -1, 1 ) === '`'
                        &&
                        val.substr( -2, 1 ) === 'n'
                        &&
                        parseInt( val, 10 ) === +( val.substring( 0, val.length - 2 ) ) 
                    ){
                        return BigInt( val.substring( 0, val.length - 2 ) );    
                    } else {
                        return val;
                    }
        
                } else {
                    return val;
                }
            }

            // handles stringifying bigint
            , _JSONstringer = function( name, val ) {
                if( 'bigint' === typeof val ) {
                    return val.toString() + 'n`';
                } else {
                    return val;
                }
            }

            // get total bytes of the specified prefixed keyname (not its value), or
            // total bytes of all prefixed keys if no key specified
            // prefix length itself is not included
            // this is storage, not consumption
            , _keyBytes = function( key ) {
                let _ourKeys     = _getAllKeysThisInstance( STRIP_THE_PREFIX ) 
                    , allStrings = _ourKeys.join( '' )
                    , size       = 0 
                ;
                
                // check all keys  
                if( 'undefined' === typeof key ) {
                    size = _getByteCount( allStrings );

                // check specified key
                } else {                        
                    if( _haskey( key ) ) {
                        size = _getByteCount( _stripPrefix( key ) );
                    } 
                }                    
                
                return size;
            }
            
            // get total bytes of the specified prefixed keyname (not its value), or
            // total bytes of all prefixed keys if no key specified
            // prefix length is included
            // this is storage, not consumption
            , _keyBytesAll = function( key ) {
                let _ourKeys     = _getAllKeysThisInstance() 
                    , allStrings = _ourKeys.join( '' )
                    , size       = 0 
                ;
                
                // check all keys
                if( 'undefined' === typeof key ) {
                    size = _getByteCount( allStrings );

                // check specified (prefixed) key
                } else {                        
                    if( _haskey( key ) ) {
                        size = _getByteCount( key );
                    } 
                }                    
                
                return size;
            }

            // get total bytes of the specified prefixed keyname (not its value), or
            // total bytes of all prefixed keys if no key specified
            // prefix length is included
            // this is consumption
            , _keyBytesMem = function( key ) {
                let _ourKeys     = _getAllKeysThisInstance() 
                    , allStrings = _ourKeys.join( '' )
                    , size       = 0 
                ;
                
                // check all keys
                if( 'undefined' === typeof key ) {
                    size = _getByteCount( allStrings );

                // check specified (prefixed) key
                } else {                        
                    if( _haskey( key ) ) {
                        size = _getByteCount( key );
                    } 
                }                    
                
                // each character is stored in UC2/UTF16 format (2 bytes storage per each byte of data)
                size *= 2;
                
                return size;
            }


            // Park Miller Lehmer LCG oneliner
            // https://gist.github.com/blixt/f17b47c62508be59987b?permalink_comment_id=2682175#gistcomment-2682175
            , _lcg=s=>()=>(2**31-1&(s=Math.imul(48271,s)))/2**31

            // Baagøe's fast hashing function
            , _Mash = function() {
                var r = 4022871197;
                return function(n) {
                    n = n.toString();
                    for (var t = 0, a = n.length; t < a; t++) {
                        r += n.charCodeAt(t);
                        var e = .02519603282416938 * r;
                        r = e >>> 0, e -= r, e *= r, r = e >>> 0, e -= r, r += 4294967296 * e;
                    }
                    return 2.3283064365386963e-10 * (r >>> 0);
                };
            }

            /*
            Mulberry32 (oneliner). Minimalistic generator utilizing a 32-bit state, originally intended for embedded applications.
            It appears to be very good; the author states it passes all tests of gjrand, and this JavaScript implementation
            is very fast. But since the state is 32-bit like Xorshift, it's period (how long the random sequence lasts before
            repeating) is significantly less than those with 128-bit states, but it's still quite large, at around 4 billion.
            see https://github.com/bryc/code/blob/master/jshash/PRNGs.md
            */
            , _mb32=a=>(t)=>(a=a+1831565813|0,t=Math.imul(a^a>>>15,1|a),t=t+Math.imul(t^t>>>7,61|t)^t,(t^t>>>14)>>>0)/2**32

            // a natural sort
            // https://stackoverflow.com/questions/14599321/javascript-natural-sort/71621852#71621852
            , _naturalSort = function( _array ) {
                return _array.sort( ( a, b ) => ( ( a + '' ).substr( 0, 1 ) === '$' 
                    ? ( a + '' ).substr( 1, ( a + '' ).length ) 
                    : ( a + '' ) ).localeCompare( b, 'en', { ignorePunctuation: true, numeric: true, sensitivity: 'base' } ) )
                ;
            }

            // main logic to determine browser localStorage quota
            , _quota = function() {
                let i = 0
                    , _qbytes
                ;
                
                try {
                    // Test up to 20 MB (this is 20 MB memory usage, 10 MB storage)
                    for( i = 250; i <= 20000; i += 250 ) {
                        localStorage.setItem( STORAGE_TEST, new Array( ( i * 1024 ) + 1 ).join( '~' ) );
                    }
                
                // set size in KB
                } catch( e ) {
                    localStorage.setItem( STORAGE_TEST + STORAGE_TEST, i - 250 );            
                }

                _qbytes = localStorage.getItem( STORAGE_TEST + STORAGE_TEST );
                _qbytes = parseInt( _qbytes, 10 );
                _qbytes *= 1000;

                _deleteLocalStorage( STORAGE_TEST );
                _deleteLocalStorage( STORAGE_TEST + STORAGE_TEST );

                return _qbytes;
            }

            // wrapper for localStorage getItem method
            , _readLocalStorage = function( key ) {
                let value;

                try {
                    value = localStorage.getItem( key );
                }
                catch( exception ) {
                    throw new Error( ERROR_21 );
                }

                return value;
            }

            // get property from object
            , _readMemoryKey = function( key ) {
                return lds[ _memoryKeyPrefix + key ]; 
            }

            , _reverse = function( _string ) {
                return Array.from( _string ).reverse().join( '' );
            }

            // create a custom event to be triggered on key name, key value or key type changes
            , _sendLocalDataStorageEvent = function( _prefix, _methodName, _msg, _oldKey, _newKey, _oldValue, _newValue, _oldType, _newType, _oldBase, _newBase ) {
                let JSONMessage = {}
                    , _timestamp = new Date() 
                    , event = new CustomEvent(
                        "localDataStorage"
                        , { 'detail' : 
                            {   'prefix'      : _prefix
                                , 'method'    : _methodName
                                , 'message'   : _msg
                                , 'date'      : _timestamp
                                , 'timestamp' : +_timestamp
                                , 'oldkey'    : _oldKey
                                , 'newkey'    : _newKey
                                , 'oldval'    : _oldType === 'bigint' ? _oldValue : JSON.stringify( _oldValue, _JSONstringer )
                                , 'newval'    : _newType === 'bigint' ? _newValue : JSON.stringify( _newValue, _JSONstringer )
                                , 'oldtype'   : _oldType
                                , 'newtype'   : _newType
                                , 'oldbase'   : _oldBase
                                , 'newbase'   : _newBase
                            }
                        , bubbles    : false
                        , cancelable : true
                        }
                    )
                ;

                document.dispatchEvent( event );

                if( _broadcastChannel !== '' ) {
                    JSONMessage = {
                        'id'          : 'localDataStorage'
                        , 'prefix'    : _prefix
                        , 'method'    : _methodName
                        , 'message'   : _msg
                        , 'date'      : _timestamp
                        , 'timestamp' : +_timestamp
                        , 'oldkey'    : _oldKey
                        , 'newkey'    : _newKey
                        , 'oldval'    : _oldType === 'bigint' ? _oldValue : JSON.stringify( _oldValue, _JSONstringer )
                        , 'newval'    : _newType === 'bigint' ? _newValue : JSON.stringify( _newValue, _JSONstringer )
                        , 'oldtype'   : _oldType
                        , 'newtype'   : _newType
                        , 'oldbase'   : _oldBase
                        , 'newbase'   : _newBase
                    }

                    ourAPIChannel.postMessage( JSONMessage );
                }
            }

            // set the verbosity value
            , _setVerbosity = function( value ) {
                _weAreVerbose = Boolean( value );
            }

            // returns an array of duplicate values (not key names), if any
            , _showDupes = function() {
                let ourKeys         = _getAllKeysThisInstance( STRIP_THE_PREFIX )
                    , keyCount      = ourKeys.length
                    , ourKeyValues  = new Array( keyCount )
                    , possibleDupes = new Array()
                ;

                for( let i = keyCount; i--; ) {
                    ourKeyValues[ i ] = _get( _getPrefixedKey( ourKeys[ i ] ) );
                }

                possibleDupes = _getStrictDuplicates( ourKeyValues );

                return possibleDupes.length === 0 ? [] : possibleDupes;
            }
            
            // shuffle a string (almost cryptographically strong when combined with XOR)
            // this is not a pure shuffle
            // this adds "noise" to the shuffled string consisting of random graphemes selected from existing ones in the _string
            , _shuffleString = function( _string, _keySeed, _keyName ) { 
                //return _string;

                const _getRandomInt = function( min, max ) {
                        return Math.floor( prng3()     * ( max - min + 1 ) ) + min;
                    }
                    , _getRandumInt = function( min, max ) {
                        return Math.floor( prng4()     * ( max - min + 1 ) ) + min;
                    }
                    , _randFloat = function () {
                        const int = window.crypto.getRandomValues( new Uint32Array( 1 ) )[ 0 ];
                        return int / 2**32;
                    }
                    , _randInt = function( min, max ) {
                        return Math.floor( _randFloat() * ( max - min + 1 ) ) + min;
                    }
                    , _noise = function( _string ) {
                        const rounds = function() { 
                                return _getRandumInt( 1, _string.length ); 
                            }
                            , adjust = function() { 
                                return prng4.range( 2, 20 ); 
                            }
                            , idx    = function() { 
                                return _getRandumInt( 0, _string.length - 1 ); 
                            } 
                        ;
                        let  output = ''
                            , runs = rounds()
                            , xtra = runs < 4 
                                ? runs + prng4.range( 3, 6 ) 
                                : runs
                        ;

                        for( let i = xtra; i--; ) {
                            output += String.fromCodePoint( _string.codePointAt( idx() ) + adjust() );
                        }

                        return output;
                    }
                ;
                let _temp    = _xmur3a( _keyName )  // get a reference to the hash function seeded with our keyname
                    , prng2  = _mb32( _temp() )     // to provide entropy, reseed the RNG each time it is called
                    
                    , _add   = _string
                    , _adder = ''
                    , _added = ''

                    , hasher = 
                        _getNumberFromObject( _keySeed )[ 0 ] + 
                        _getNumberFromObject( _keyName )[ 0 ]
                    , hashed = ( _foldFPHash( hasher ) + '' )
                    , hashor = _reverse( hashed )
                    , hashee = Number( hashor )
                    , hashey = '' + hashee + hasher
                    , addendum = _randInt( 100, 999 ) + ''
                    , prng1  = _aleaPRNG( hashey, hashed, hashor + addendum )

                    , ivprep = 
                        Number( ( hashee + '' ).charAt( 2 ) ) + 
                        Number( ( hashee + '' ).charAt( 1 ) ) + 
                        Number( ( hashee + '' ).charAt( 0 ) )  
                    , ivrounds = 
                        _getCodePointCount( _getNumberFromObject( _keyName )[ 1 ] ) + 
                        _getCodePointCount( _getNumberFromObject( _keySeed )[ 1 ] ) + 
                        ivprep

                    // this logic is only needed to shuffle (not to unshuffle)
                    , _temper  = JSON.stringify( _keySeed, _JSONstringer )
                    , _tempest = _xmur3a( _temper )
                    , prng3    = _lcg( _tempest() )

                    // unseeded (monte carlo)
                    , prng4    = _aleaPRNG()
                ;


                // clock the generators
                for( let i = ivrounds; i--; ) {
                    if( prng1() < .75 ) {
                        prng2();
                    }

                    // this logic clocks prng3 off of prng2 and while prng3 is only needed to shuffle,
                    // not to unshuffle, we still have to do the extra clocking of prng2 in the unshuffle
                    if( prng2() > .75 ) {
                        prng3();
                    }
                }


                // shuffle the individual words (if there are any)
                if( prng2() > .5 ) {
                    _adder = _string.split( ' ' );
                  
                    for( let i = 0; i < _adder.length; i++ ) {
                        _added = _adder[ i ];
                        
                        if( _added.length > 2 ) {
                            _added = _added.split( '' );
                            _fisherYatesDurstenfeldKnuthShuffle( _added, prng2 );
                            _added = _added.join( '' );
                        }

                        _adder[ i ] = _added;
                    }

                    _string = _adder.join( ' ' );
                }


                // add a marker flag and then the "noise" (composed of a subset of the same graphemes as the data)
                // once shuffled, the data and noise are indistinguishable 
                _string += SHUFFLE_MARKER; // + _noise( _add );

                // shuffle the string
                _string = _string.split( '' );
                _fisherYatesDurstenfeldKnuthShuffle( _string, prng1 );
                _string = _string.join( '' );

                return _string + addendum;
            }

            // 7-bit ASCII text de/compressor
            , _smidge = function() {
                const e = function() {};
                return e.codebook = {
                    " ": 0, the: 1, '","': 2, '":"': 3, '"}}': 4, of: 5, o: 6, and: 7, '":{"': 8, n: 9, s: 10, "e ": 11, r: 12, " th": 13, " t": 14, in: 15, he: 16, th: 17, h: 18, "he ": 19, to: 20, "\r\n": 21, l: 22, "s ": 23, d: 24, " a": 25, an: 26, er: 27, c: 28, " o": 29, "d ": 30, on: 31, " of": 32, re: 33, "of ": 34, "t ": 35, ", ": 36, is: 37, u: 38, at: 39, "   ": 40, "n ": 41, or: 42, which: 43, f: 44, m: 45, as: 46, it: 47, that: 48, "\n": 49, was: 50, en: 51, "  ": 52, " w": 53, es: 54, " an": 55, " i": 56, "\r": 57, "f ": 58, g: 59, p: 60, nd: 61, " s": 62, "nd ": 63, "ed ": 64, w: 65, ed: 66, "https://": 67, for: 68, te: 69, ing: 70, "y ": 71, The: 72, " c": 73, ti: 74, "r ": 75, his: 76, st: 77, " in": 78, ar: 79, nt: 80, ",": 81, " to": 82, y: 83, ng: 84, " h": 85, with: 86, le: 87, al: 88, "to ": 89, b: 90, ou: 91, be: 92, were: 93, " b": 94, se: 95, "o ": 96, ent: 97, ha: 98, "ng ": 99, their: 100, '"': 101, hi: 102, from: 103, " f": 104, "in ": 105, de: 106, ion: 107, me: 108, v: 109, ".": 110, ve: 111, all: 112, "re ": 113, ri: 114, ro: 115, "is ": 116, co: 117, "f t": 118, are: 119, ea: 120, ". ": 121, her: 122, " m": 123, "er ": 124, " p": 125, "es ": 126, by: 127, they: 128, di: 129, ra: 130, ic: 131, not: 132, "s, ": 133, "d t": 134, "at ": 135, ce: 136, la: 137, "h ": 138, ne: 139, "as ": 140, tio: 141, "on ": 142, "n t": 143, io: 144, we: 145, " a ": 146, om: 147, ", a": 148, "s o": 149, ur: 150, li: 151, ll: 152, ch: 153, had: 154, this: 155, "e t": 156, "g ": 157, "e\r\n": 158, " wh": 159, ere: 160, " co": 161, "e o": 162, "a ": 163, us: 164, " d": 165, ss: 166, "\n\r\n": 167, "\r\n\r": 168, '="': 169, " be": 170, " e": 171, "s a": 172, ma: 173, one: 174, "t t": 175, "or ": 176, but: 177, el: 178, so: 179, "l ": 180, "e s": 181, "s,": 182, no: 183, ter: 184, " wa": 185, iv: 186, ho: 187, "e a": 188, " r": 189, hat: 190, "s t": 191, ns: 192, "ch ": 193, wh: 194, tr: 195, ut: 196, "/": 197, have: 198, "ly ": 199, ta: 200, " ha": 201, " on": 202, tha: 203, "-": 204, " l": 205, ati: 206, "en ": 207, pe: 208, " re": 209, there: 210, ass: 211, si: 212, " fo": 213, wa: 214, ec: 215, our: 216, who: 217, its: 218, "https://www.": 219, fo: 220, rs: 221, ">": 222, ot: 223, un: 224, "<": 225, im: 226, "th ": 227, nc: 228, ate: 229, "><": 230, ver: 231, ad: 232, " we": 233, ly: 234, ee: 235, " n": 236, id: 237, " cl": 238, ac: 239, il: 240, "</": 241, rt: 242, " wi": 243, div: 244, "e, ": 245, " it": 246, whi: 247, " ma": 248, ge: 249, x: 250, "e c": 251, men: 252, ".com": 253
                }, e.make_reverse_codebook = function(e) {
                    let t = new Array(e.length),
                        o = 0;
                    for (let n in e) t[o++] = n;
                    return t
                }, e.flush_verbatim = function(e) {
                    var t, o, n, r;
                    for (o = [], e.length > 1 ? (o.push(String.fromCodePoint(255)), o.push(String.fromCodePoint(e.length - 1))) : o.push(String.fromCodePoint(254)), n = 0, r = e.length; n < r; n++) t = e[n], o.push(t);
                    return o
                }, e.compress = function(t) {
                    var o, n, r, h, s, i, a;
                    for (i = "", s = [], r = 0; r < t.length;) {
                        for (n = !1, h = e.longestKeyLength, t.length - r < e.longestKeyLength && (h = t.length - r), h = a = h; h <= 0 ? a < 0 : a > 0; h = h <= 0 ? ++a : --a)
                            if (null != (o = e.codebook[t.substr(r, h)])) {
                                i && (s = s.concat(e.flush_verbatim(i)), i = ""), s.push(String.fromCodePoint(o)), r += h, n = !0;
                                break
                            }
                        n || (i += t[r], r++, 256 === i.length && (s = s.concat(e.flush_verbatim(i)), i = ""))
                    }
                    return i && (s = s.concat(e.flush_verbatim(i))), s.join("")
                }, e.decompress = function(t) {
                    var o, n, r, h, s, i;
                    for (h = "", n = function() {
                            var e, n, r;
                            for (r = [], o = e = 0, n = t.length; 0 <= n ? e < n : e > n; o = 0 <= n ? ++e : --e) r.push(t.codePointAt(o));
                            return r
                        }(), o = 0; o < n.length;)
                        if (254 === n[o]) {
                            if (o + 1 > n.length) throw "Malformed SMAZ";
                            h += t[o + 1], o += 2
                        } else if (255 === n[o]) {
                        if (o + n[o + 1] + 2 >= n.length) throw "Malformed SMAZ";
                        for (r = s = 0, i = n[o + 1] + 1; 0 <= i ? s < i : s > i; r = 0 <= i ? ++s : --s) h += t[o + 2 + r];
                        o += 3 + n[o + 1]
                    } else h += e.reverse_codebook[n[o]], o++;
                    return h
                }, e.getLongestKeyLength = function(e) {
                    let t = 0,
                        o = 0;
                    for (let n = 0; n < e.length; n++) e[n].length > o && (t = n, o = e[n].length);
                    return e[t].length
                }, e.reverse_codebook = e.make_reverse_codebook(e.codebook), e.longestKeyLength = e.getLongestKeyLength(e.reverse_codebook), e
            }()

            // remove _prefix, and return just the key
            , _stripPrefix = function ( _key ) {
                return _key.slice( _getKeyPrefix().length, _key.length );
            }

            // remove the memory key prefix, and return just the key
            , _stripMemKeyPrefix = function ( _key ) {
                return _key.replace( _memoryKeyPrefix, '' );
            }

            // helper function called by _getCodePointCount
            , __ucs2decode = function( t ) {
                for( var r, n, e = [], o = 0, u = t.length; u > o; ) r = t.charCodeAt(o++), r >= 55296 && 56319 >= r && u > o ? (n = t.charCodeAt(o++), 56320 == (64512 & n) ? e.push(((1023 & r) << 10) + (1023 & n) + 65536) : (e.push(r), o--)) : e.push(r);
                return e;
            }

            // decompress simple 7-bit ASCII text strings
            , _uncrunch = function( _crunchedText ) {
                return _smidge.decompress( _crunchedText );
            }

            // restore a shuffled string
            , _unshuffleString = function( _stringer, _keySeed, _keyName ) {
                let addendum  = _stringer.substr( -3 )
                    , _string = _stringer.replace( addendum, '' )
                    , _temp   = _xmur3a( _keyName )
                    , prng2   = _mb32( _temp() )
                    , _add    = _string

                    , _adder  = ''
                    , _added  = ''
                    , _indx   = 0

                    , hasher  = 
                        _getNumberFromObject( _keySeed )[ 0 ] + 
                        _getNumberFromObject( _keyName )[ 0 ]
                    , hashed  = ( _foldFPHash( hasher ) + '' )
                    , hashor  = _reverse( hashed )
                    , hashee  = Number( hashor )
                    , hashey  = '' + hashee + hasher
                    , prng1   = _aleaPRNG( hashey, hashed, hashor + addendum )
                    , ivprep  = 
                        Number( ( hashee + '' ).charAt( 2 ) ) + 
                        Number( ( hashee + '' ).charAt( 1 ) ) + 
                        Number( ( hashee + '' ).charAt( 0 ) )  
                    , ivrounds  = 
                        _getCodePointCount( _getNumberFromObject( _keyName )[ 1 ] ) + 
                        _getCodePointCount( _getNumberFromObject( _keySeed )[ 1 ] ) + 
                        ivprep
                ;
                const noop = function(){}; 

                // clock the generators
                for( let i = ivrounds; i--; ) {
                    if( prng1() < .75 ) {
                        prng2();
                    }

                    // this logic clocks prng3 off of prng2 and while prng3 is only needed to shuffle,
                    // not to unshuffle, we still have to do the extra clocking of prng2 in the unshuffle
                    if( prng2() < .25 ) {
                        noop();
                    }
                }


                // unshuffle the string
                _string = _string.split( '' );
                _string = _fisherYatesDurstenfeldKnuthUnshuffle( _string, prng1 );
                _string = _string.join( '' );
                
                // locate the marker flag and remove everything after it
                _indx = _string.indexOf( SHUFFLE_MARKER );
                _string = _string.substr( 0, _indx );


                // unshuffle the individual words
                if( prng2() > .5 ) {
                    _adder = _string.split( ' ' );
                  
                    for( let i = 0; i < _adder.length; i++ ) {

                        _added = _adder[ i ];
                        
                        if( _added.length > 2 ) {
                            _added = _added.split( '' );
                            _added = _fisherYatesDurstenfeldKnuthUnshuffle( _added, prng2 );
                            _added = _added.join( '' );
                        }

                        _adder[ i ] = _added;
                    }

                    _string = _adder.join( ' ' );
                }

                return _string;
            }

            , _updateLengthProp = function() {
                setTimeout( () => lds.length = _getAllKeysThisInstance().length, 0 );
                
                // housekeeping
                lds.version = 'localDataStorage ' + VERSION;
            }

            // get total bytes of the specified (prefixed) key's value, or
            // total bytes of all prefixed key values if no key specified
            // does not include flags
            // storage not consumption
            , _valBytes = function( key ) {
                let allStrings = ''
                    , size     = 0
                    , ourKeys  = new Array() 
                    , keyCount = 0
                    , ourKey   = ''
                    , ourKeyValue = ''
                ;
                 
                // check all keys
                if( 'undefined' === typeof key ) {
                    ourKeys  = _getAllKeysThisInstance();
                    keyCount = ourKeys.length;

                    for( let i = keyCount; i--; ) {
                        ourKey = ourKeys[ i ];
                            
                        ourKeyValue = _readLocalStorage( ourKey );

                        // remove flags
                        ourKeyValue = ourKeyValue.replace( TYPE_ARRAY,     '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_BIGINT,    '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_BOOLEAN,   '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_DATE,      '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_NUMBER,    '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_OBJECT,    '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_STRING,    '' );

                        ourKeyValue = ourKeyValue.replace( TYPE_CRUNCH,    '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_OBFUSCATE, '' );

                        allStrings += ourKeyValue;   
                    }
            
                    size = _getByteCount( allStrings );
                
                // check specified key
                } else {                        

                    if( _haskey( key ) ) {
                        
                        //if( _getTypeOfKey( ourKey ) === 'compressed string' ) {
                        ourKeyValue = _readLocalStorage( key );

                        // remove flags
                        ourKeyValue = ourKeyValue.replace( TYPE_ARRAY,     '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_BIGINT,    '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_BOOLEAN,   '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_DATE,      '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_NUMBER,    '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_OBJECT,    '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_STRING,    '' );

                        ourKeyValue = ourKeyValue.replace( TYPE_CRUNCH,    '' );
                        ourKeyValue = ourKeyValue.replace( TYPE_OBFUSCATE, '' );

                        size = _getByteCount( ourKeyValue );
                    }
                }                    
                
                return size;
            }

            // get total bytes of the specified (prefixed) key's value, or
            // total bytes of all prefixed key values if no key specified
            // includes flags
            // storage not consumption
            , _valBytesAll = function( key ) {
                let allStrings = ''
                    , size     = 0
                    , ourKeys  = new Array() 
                    , keyCount = 0
                    , ourKey   = ''
                    , ourKeyValue = ''
                ;
                 
                // check all keys
                if( 'undefined' === typeof key ) {
                    ourKeys  = _getAllKeysThisInstance();
                    keyCount = ourKeys.length;

                    for( let i = keyCount; i--; ) {
                        ourKey = ourKeys[ i ];
                            
                        ourKeyValue = _readLocalStorage( ourKey );

                        allStrings += ourKeyValue;   
                    }
            
                    size = _getByteCount( allStrings );
                
                // check specified key
                } else {                        

                    if( _haskey( key ) ) {
                        
                        //if( _getTypeOfKey( ourKey ) === 'compressed string' ) {
                        ourKeyValue = _readLocalStorage( key );

                        size = _getByteCount( ourKeyValue );
                    }
                }                    
                
                return size;            
            }

            // get total bytes of the specified (prefixed) key's value, or
            // total bytes of all prefixed key values if no key specified
            // includes flags
            // consumption
            , _valBytesMem = function( key ) {
                return _valBytesAll( key ) * 2;
            }

            // check if the value's type is supported
            , _valueIsIllegalType = function( value ) {
                let _return = true
                    , _len  = SUPPORTED_TYPES.length
                    , _type = typeof value
                ;

                for( let i = _len; i--; ) {
                    if( _type === SUPPORTED_TYPES[ i ] ) {
                        _return = false;
                        break;
                    }
                }

                return _return;
            }

            // performs identity check
            , _valuesAreEqual = function( val1, val2 ) {
                if( JSON.stringify( val1, _JSONstringer ).substr( -1 ) === ']' ) {
                    return _arraysAreEqual( val1, val2 );
                } else {
                    return ( val1 === val2 );
                }
            }

            // wrapper for localStorage setItem method
            , _writeLocalStorage = function( key, value ) {
                if( 'undefined' === typeof key   ) { throw new Error( ERROR_11 ); }
                if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }

                try {
                    localStorage.setItem( key, value );
                }
                catch( exception ) {
                    if( exception &&
                        (
                            exception.name === 'QUOTA_EXCEEDED_ERR'         ||
                            exception.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||
                            exception.name === 'QuotaExceededError'
                        )
                    ){
                        throw new Error( ERROR_22 );

                    } else {
                        throw new Error( ERROR_23 );
                    }
                }
            }

            // based on murmurhash3 mixing function
            // https://github.com/bryc/code/blob/master/jshash/PRNGs.md
            , _xmur3a = function( str ) {
                for(var k, i = 0, h = 2166136261 >>> 0; i < str.length; i++) {
                    k = Math.imul(str.charCodeAt(i), 3432918353); k = k << 15 | k >>> 17;
                    h ^= Math.imul(k, 461845907); h = h << 13 | h >>> 19;
                    h = Math.imul(h, 5) + 3864292196 | 0;
                }
                h ^= str.length;
                return function() {
                    h ^= h >>> 16; h = Math.imul(h, 2246822507);
                    h ^= h >>> 13; h = Math.imul(h, 3266489909);
                    h ^= h >>> 16;
                    return h >>> 0;
                }
            }

            // XOR _string against a PRNG seeded with _keySeed
            , _xorString = function( _string, _keySeed, _keyName ) {
                let _temper    = JSON.stringify( _keySeed, _JSONstringer )
                    , _tempest = _xmur3a( _temper )
                    , prng3    = _lcg( _tempest() )

                    , _temp  = _xmur3a( _keyName )  // get a reference to the hash function seeded with our keyname
                    , prng2  = _mb32( _temp() )     // to provide entropy, reseed the RNG each time it is called
                 
                    , output = ''
                    , hasher = _getNumberFromObject( _keySeed )[ 0 ]
                    , hashed = ( _foldFPHash( hasher ) + '' )
                    , hashor = _reverse( hashed )
                    , hashee = 
                        Number( hashor )                      + 
                        _getNumberFromObject( _keyName )[ 0 ] +
                        _getNumberFromObject( _keySeed )[ 0 ]
                    , hashim = ( hashee + '' )
                    , hasham = ( hasher + '' )
                    , hashem = ( _tempest() + '' )
                    , prng1 = _aleaPRNG( hashim, hasham, hashem )

                    , ivprep = 
                        hasher + 
                        Number( ( hashee + '' ).charAt( 0 ) ) + 
                        Number( ( hashee + '' ).charAt( 1 ) ) + 
                        Number( ( hashee + '' ).charAt( 2 ) ) + 
                        Number( ( hashed      ).charAt( 0 ) )  
                    , ivrounds = 
                        _getCodePointCount( _getNumberFromObject( _keyName )[ 1 ] ) + 
                        _getCodePointCount( _getNumberFromObject( _keySeed )[ 1 ] ) + 
                        ivprep 
                    , hashes = _Mash()
                    , hashet = _getNumberFromObject( _keySeed )[ 1 ]
                    , keyA =   0
                    , keyB =   0
                    , minA =   0
                    , maxA = 255
                    , minB =   0
                    , maxB =   0
                ;
                const _getRandomInt = function( min, max ) {
                    return Math.floor( prng3() * ( max - min + 1 ) ) + min;
                }

  
                _string += '';

                // clock the generators
                for( let i = 0; i < ivrounds; i++ ) {
                    if( prng1() > .75 ) {
                        prng2();
                    }

                    if( prng2() > .55 ) {
                        prng3();
                    }
                }

                for( let i = 0, l = _string.length; i < l; i++ ) {
                    keyA = Math.floor( prng1()          * ( maxA - minA + 1 ) ) + minA;
                    if( prng2() < .45 ) { keyA += _getRandomInt( 1, 100 ); }

                    minB = keyA;
                    maxB = hasher;
                    keyB = Math.floor( hashes( hashet ) * ( maxB - minB + 1 ) ) + minB;  

                    if( prng1() < prng2() ) {
                        output += String.fromCodePoint( keyA ^ _string.codePointAt( i ) );

                    } else {
                        output += String.fromCodePoint( keyB ^ _string.codePointAt( i ) );
                    }
                }

                return output;
            }
        
            // show some internals
            , lds = function( weShowVerboseOutput = false ) {
                let _quotaPhrase = ''
                    , _broadcastPhrase = _broadcastChannel === '' ? ' (not currently broadcasting)' : ', broadcasting on channel ' + _broadcastChannel
                ;

                if( weShowVerboseOutput ) {
                    _quotaPhrase = _weAreVerbose === true ? '. ' + lds.showquotaused() : ' where ' + _describeSize( lds.showquotaused( true ) ) + ' are used';

                    return 'localDataStorage v' + VERSION + ' (checksum ' + _checksum + ') using ' + ( _prefix === '' ? 'no prefix' : 'prefix ' + _prefix ) + ' with quota of ' + lds.quota + _quotaPhrase + _broadcastPhrase; 
                } else {
                    return _getIdentity();
                }
            }
        ;

        // transfer key data from a memory key to a local storage key
        // this is a transfer, not a sync
        // the destination key is created (or overwritten) and the source key is deleted 
        lds._backup = function( key, weOverwriteExistingKey ) {
            if( !_storageIsAvailable() ) { return false; }
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }

            // check if memory key exists
            if( !lds._haskey( key ) ) { throw new Error ( ERROR_42 ); }

            // get the memory key value and type 
            let memKeyValue  = lds._get( key )
                , memKeyType = lds._showtype( key )
                , newDiskKeyValue = ''
                , newDiskKeyType  = ''
                , oldDiskKeyValue = ''
                , oldDiskKeyType  = ''
            ;

            const writeDiskKey = function() {
                // get the value type
                newDiskKeyValue = _convertToString( memKeyValue )[ 0 ];

                // store the memory key to a local storage key
                _writeLocalStorage( _getPrefixedKey( key ), newDiskKeyValue );
            }

            // check if this key exists in local storage
            if( _haskey( _getPrefixedKey( key ) ) ) {
                if( weOverwriteExistingKey ) {
                    
                    oldDiskKeyValue = _getTheKey( key );
                    oldDiskKeyType  = _getTypeOfKey( _getPrefixedKey( key ) );

                    writeDiskKey();

                    newDiskKeyValue = _getTheKey( key );
                    newDiskKeyType  = _getTypeOfKey( _getPrefixedKey( key ) );

                    // verify backup
                    if( _valuesAreEqual( memKeyValue, newDiskKeyValue ) && memKeyType === newDiskKeyType ) {
                        
                        // delete memory key
                        lds._remove( key );
        
                        _sendLocalDataStorageEvent( _getKeyPrefix(), 'backup', 'key value change', key, key, oldDiskKeyValue, newDiskKeyValue, oldDiskKeyType, newDiskKeyType, 'memory', 'disk' );

                        if( _weAreVerbose ) { return "Existing localStorage key has been overwritten by Memory Key and the value verified"; }

                    } else {
                        throw new Error ( ERROR_45 );
                    }

                } else {
                    throw new Error( ERROR_40 );
                }

            } else {
                writeDiskKey();

                newDiskKeyValue = _getTheKey( key );
                newDiskKeyType  = _getTypeOfKey( _getPrefixedKey( key ) );

                // verify backup
                if( _valuesAreEqual( memKeyValue, newDiskKeyValue ) && memKeyType === newDiskKeyType ) {
                    lds._remove( key );

                    _sendLocalDataStorageEvent( _getKeyPrefix(), 'backup', 'create new key', undefined, key, undefined, newDiskKeyValue, undefined, newDiskKeyType, 'memory', 'disk' );

                    if( _weAreVerbose ) { return "New localStorage created from Memory Key (value verified)"; }

                } else {
                    throw new Error ( ERROR_46 );
                }
            }
        }

        lds.broadcast = function( _channelName ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof _channelName ) { throw new Error( ERROR_44 ); }

            if( _channelName === '' ) {
                ourAPIChannel.close();
                if( _weAreVerbose ) { console.log( 'Broadcast Channel API closed' ); }
            
            } else {
                _broadcastChannel = _channelName;

                //setup broadcast channel
                ourAPIChannel = new BroadcastChannel( _broadcastChannel );

                if( _weAreVerbose ) { console.log( `Broadcasting on channel ${ _broadcastChannel }` ); }
            }
        }

        // returns total bytes used by all key names and all key data, in the domain
        // if a key is specified, returns data for that key alone
        // storage requirements for the embedded flags are not considered, just the raw data
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.bytes = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _temp;

            if( 'undefined' === typeof key ) {
                return _describeSize( _valBytes() + _keyBytes() );
            } else {
                _temp = _describeSize( _valBytes( _getPrefixedKey( key ) ) + _keyBytes( _getPrefixedKey( key ) ) );
                return _temp !== '0 bytes' ? _temp : undefined;    
            }
        }

        // returns total bytes used by all key names and all key data, in the domain
        // if a key is specified, returns data for that key alone
        // storage requirements for the embedded flags are counted, providing total storage use
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.bytesall = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _temp;

            if( 'undefined' === typeof key ) {
                return _describeSize( _valBytesAll() + _keyBytesAll() );
            } else {
                _temp = _describeSize( _valBytesAll( _getPrefixedKey( key ) ) + _keyBytesAll( _getPrefixedKey( key ) ) );
                return _temp !== '0 bytes' ? _temp : undefined;    
            }
        }

        // returns total bytes used by all key names and all key data, in the domain
        // if a key is specified, returns data for that key alone
        // storage requirements for the embedded flags are counted, providing total storage use
        // returns memory consumption, not storage
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.bytesmem = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _temp;

            if( 'undefined' === typeof key ) {
                return _describeSize( _valBytesMem() + _keyBytesMem() );
            } else {
                _temp = _describeSize( _valBytesMem( _getPrefixedKey( key ) ) + _keyBytesMem( _getPrefixedKey( key ) ) );
                return _temp !== '0 bytes' ? _temp : undefined;    
            }
        }

        // return boolean whether the string value can be compressed (crunched)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.cancrunch = function( value ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( 'string'    !== typeof value ) { throw new Error( ERROR_37 ); }
            
            return _isCrunchable( value );  
        }

        // get key and immediately remove it
        // fails silently returning undefined if key does not exist
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.chopget = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _oldValue
                , _oldType
            ;

            if( _haskey( _getPrefixedKey( key ) ) ) {
                _oldValue = _getTheKey( key );
                _oldType  = _getTypeOfKey( _getPrefixedKey( key ) );

                _deleteLocalStorage( _getPrefixedKey( key ) );

                _sendLocalDataStorageEvent( _getKeyPrefix(), 'chopget', 'excise key', key, undefined, _oldValue, undefined, _oldType, undefined, 'disk', 'disk' );

                lds.length -= 1;
                _updateLengthProp();

                return _oldValue;
            
            } else {
                return undefined;
            }
        }

        lds._chopget = function( key ) {
            let _oldValue
                , _oldType
            ;

            if( lds._haskey( key ) ) {
                _oldValue = lds._get( key );

                lds._remove( key );

                return _oldValue;
            
            } else {
                return undefined;
            }
        }


        // deletes all prefixed keys, in the domain, using the native API
        // does not delete keys created outside this instance
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.clear = function() {
            if( !_storageIsAvailable() ) { return false; }

            let _ourKey
                , _oldValue
                , _oldType
                , _keyPrefix = _getKeyPrefix()
                , _tempKeys  = _getAllKeysThisInstance()
                , _keyCount  = _tempKeys.length
            ;

            for( let i = _keyCount; i--; ) {

                _ourKey = _tempKeys[ i ];

                _oldValue = _get( _ourKey );
                _oldType  = _getTypeOfKey( _ourKey );

                _deleteLocalStorage( _ourKey );

                _sendLocalDataStorageEvent( _keyPrefix, 'clear', 'remove all keys', _ourKey, undefined, _oldValue, undefined, _oldType, undefined, 'disk', 'disk' );
            }

            lds.length = 0;

            return _keyCount === 1 ? '1 key removed' : _keyCount + ' keys removed';
        }

        lds._clear = function() {
            let memKeys = _getAllMemoryKeysThisInstance()
                , keyCount = memKeys.length
            ;

            for( let i = keyCount; i--; ) {
                Reflect.deleteProperty( lds, memKeys[ i ] );
            }
        }

        // checks whether key (which must be of type array) contains value
        // ex. string search for value 'english' in education key [ 'math', 'english', 'science' ]
        // ex. object search for value {'book':'math'} in education key [ {'book':'math'}, {'book':'english'}, {'book':'science'} ]
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.contains = function( key, value ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key   ) { throw new Error( ERROR_11 ); }
            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }


            if( !_haskey( _getPrefixedKey( key ) ) ) { return undefined; }

            if( 'array' !== _getTypeOfKey( _getPrefixedKey( key ) ) ) { throw new Error( ERROR_16 ); }

            let _return = false
                , _value = _getTheKey( key )
            ;

            for( let i = 0; i < _value.length; i++ ) {
                if( JSON.stringify( _value[ i ], _JSONstringer ) === JSON.stringify( value, _JSONstringer ) ) {
                    _return = true;
                    break;
                }
            }

            return _return;
        }

        // creates new key key2 and assigns value of existing key1 to it
        // does not work for scrambled keys
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.copy = function( key1, key2 ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key1 ) { throw new Error( ERROR_33 ); }
            if( 'undefined' === typeof key2 ) { throw new Error( ERROR_34 ); }

            if( !_haskey( _getPrefixedKey( key1 ) ) ) { throw new Error( ERROR_35 ); }
            if(  _haskey( _getPrefixedKey( key2 ) ) ) { throw new Error( ERROR_36 ); }

            let sharedVal = _readLocalStorage( _getPrefixedKey( key1 ) )
                , type
            ;

            if( sharedVal.substr( 0, 1 ) === TYPE_OBFUSCATE ) { throw new Error( ERROR_38 ); } 

            type = _getTypeOfKey( null, sharedVal );

            _writeLocalStorage( _getPrefixedKey( key2 ), sharedVal );

            _sendLocalDataStorageEvent( _getKeyPrefix(), 'copy', 'create new key', key1, key2, undefined, sharedVal, undefined, type, 'disk', 'disk' );

            lds.length += 1;
            _updateLengthProp();

            if( _weAreVerbose ) { return "Created new key " + key2 + " with value copied from existing key " + key1; }
        }

        // returns a count of duplicate key values, if any
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.countdupes = function() {
            if( !_storageIsAvailable() ) { return false; }

            let output  = ''
                , tally = _showDupes().length
            ;

            output = tally === 0
                ? 'No duplicate values'
                : tally === 1
                    ? 'One duplicate value'
                    : tally + ' duplicate values'
            ;

            if( _weAreVerbose ) { 
                return output + " in storage"; 
            } else {
                return _showDupes().length;
            }
        }

        // returns compressed text
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.crunch = function( _text ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'symbol' === typeof _text ) { throw new Error( ERROR_13 ); }

            return _crunch( _text );
        }

        // create JSON of key value pairs for subsequent import
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.export = function( mode = 'unsafe' ) {
            if( !_storageIsAvailable() ) { return false; }

            let ourKeys        = _getAllKeysThisInstance( STRIP_THE_PREFIX )
                , keyCount     = ourKeys.length
                , keyPrefix    = _prefix
                , ourKeyValues = new Array( keyCount )
                , keyValPairs  = new Array()
                , kvpair       = new Array()
                , exportTime   = +( new Date() )
                , exObject     = {}
            ;

            // set default import mode
            if( mode !== "safe" && mode !== "unsafe" ) { mode = "unsafe"; }

            for( let i = 0; i < keyCount; i++ ) {
                ourKeyValues[ i ] = _readLocalStorage( _prefix + '.' + ourKeys[ i ] );

                //kvpair[ i ] = [ _crunch( ourKeys[ i ] ), _crunch( ourKeyValues[ i ] ) ];
                kvpair[ i ] = [ ourKeys[ i ], ourKeyValues[ i ] ];

                keyValPairs.push( kvpair[ i ] );

                _naturalSort( keyValPairs );

                exObject = {
                    "ts"         : exportTime
                    , "mode"     : mode
                    , "keycount" : keyCount
                    , "prefix"   : keyPrefix
                    , "keys"     : keyValPairs 
                }
            }

            return exObject;
        }

        // boolean test whether value exists as native localStorage string
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.forcehasval = function( value ) {
            if( !_storageIsAvailable() ) { return false; }

            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }

            let _return = false
                , _len = localStorage.length
            ;

            for( let i = _len; i--; ) {
                if( value == _readLocalStorage( localStorage.key( i ) ) ) { _return = true; }
            }

            return _return;
        } 

        // get the key, but neither perform type checking nor attempt to restore data type based on composition
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.forceget = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return _readLocalStorage( _getPrefixedKey( key ) );
        }

        // set the prefixed key, but neither perform type checking nor embed flags based on composition 
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.forceset = function( key, value ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key   ) { throw new Error( ERROR_11 ); }
            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }

            let _incomingValueType = _getTypeOf( value ) //_getTypeOfKey( 'anyKeyName', value )
                , _oldValue        = _getTheKey( key )
                , _oldType         = _getTypeOfKey( _getPrefixedKey( key ) )
                , _oldValueTest    = _oldType === 'bigint' ? _oldValue : JSON.stringify( _oldValue, _JSONstringer )
                , _newValue        = _incomingValueType === 'bigint' ? value + 'n' : value + ''
                , _newType         = 'string' // always string
                , _newValueTest    = _newType === 'bigint' ? _newValue : JSON.stringify( _newValue, _JSONstringer )
            ;

            if( _incomingValueType === 'bigint' ) {
                value += 'n';
            } else {
                value += '';
            }
            _writeLocalStorage( _getPrefixedKey( key ), value );

            if( _oldValueTest !== _newValueTest || _oldType !== _newType ) {
                if( 'undefined' === typeof _oldValue ) {
                    _sendLocalDataStorageEvent( _getKeyPrefix(), 'forceset', 'create new key',  undefined, key, _oldValue, _newValue, _oldType, _newType, 'disk', 'disk' );

                    lds.length += 1;
                    _updateLengthProp();

                } else {
                    _sendLocalDataStorageEvent( _getKeyPrefix(), 'forceset', 'key value change', key, undefined, _oldValue, _newValue, _oldType, _newType, 'disk', 'disk' );
                }
            }
        }

        // gets value of key, respecting its type if set by this utility;
        // otherwise returns obvious object if it can be deduced, else returns typical localStorage string
        // key is unique
        // fails silently returning undefined if key does not exist
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.get = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            return _getTheKey( key );
        }

        lds._get = function( key ) {
            let val = Reflect.get( lds, _memoryKeyPrefix + key );
            //return lds[ _memoryKeyPrefix + key ];

            // this is necessary in case we have a compressed string
            // all other types are fine
            if( typeof val === 'string' ) { val = _convertFromString( val ); }
            return val;
        }

        // returns the "global" scramble key
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.getscramblekey = function() {
            if( !_storageIsAvailable() ) { return false; }

            return _scrambleKey;
        }

        // boolean check whether key exists (under this prefix in this domain)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.haskey = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            return _haskey( _getPrefixedKey( key ) );
        }

        lds._haskey = function( key ) {
            return Reflect.has( lds, _memoryKeyPrefix + key );
        }

        // boolean check whether type of value exists in store (under this prefix in this domain)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.hastype = function( type ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof type ) { throw new Error( ERROR_18 ); }

            if( type.toLowerCase() === "symbol" ) { throw new Error( ERROR_13 ); }

            if( !SUPPORTED_TYPES.includes( type.toLowerCase() ) ) { throw new Error( ERROR_17 ); }

            type = type.toLowerCase();

            let _tempType   = ''
                , _tempKeys = _getAllKeysThisInstance()
                , _len      = _tempKeys.length
                , _key
                , _found    = false
            ;

            for( let i = _len; i--; ) {
                _key = _tempKeys[ i ];
                _tempType = _getTypeOfKey( _key );
                
                if(
                    ( type === "number"  && ( _tempType === "float" || _tempType === "integer" ) )
                    ||
                    ( type !== "number"  &&   _tempType === type )
                ){

                    _found = true;
                    break;
                }
            }

            return _found;
        }

        // boolean check whether value exists (under this prefix in this domain)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.hasval = function( value ) {
            if( !_storageIsAvailable() ) { return false; }

            return _hasval( value );
        }

        // read JSON of key value pairs for import
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.import = function( _exObject, mode = '' ) {
            if( !_storageIsAvailable() ) { return false; }

            let ourKey = new Array()
                , keyName
                , keyValue
                , keyCount   = _exObject.keycount
                , keyPrefix  = _exObject.prefix
                , exportDate = new Date( _exObject.ts )
                , exportMode = _exObject.mode
                , tally      = 0
                , thisPrefix = _prefix
                , output     = ''
                , actualKey  = ''
                , actualVal  
            ;

            // check and set default import mode from object
            if( exportMode !== "safe" && exportMode !== "unsafe" ) { exportMode = "unsafe"; }

            // check and set default import mode from argument, and overwrite exportMode if set
            if( mode !== '' ) {
                if( mode   !== "safe" && mode       !== "unsafe" ) { mode       = "unsafe"; }
                exportMode = mode;
            }


            if( exportMode === "safe" ) {
                console.log( 'Importing upto ' + keyCount + ( keyCount === 1 ? ' key ' : ' keys ' ) + 'from ' + exportDate + '...' );
            } else {
                console.log( 'Overwriting '    + keyCount + ( keyCount === 1 ? ' key ' : ' keys ' ) + 'from ' + exportDate + '...' );
            }

            // make sure our import keys match the current prefix
            if( thisPrefix === keyPrefix ) {
                for( let i = 0; i < keyCount; i++ ) {
                    ourKey = _exObject.keys[ i ];

                    //keyName  = _uncrunch( ourKey[ 0 ] );
                    //keyValue = _uncrunch( ourKey[ 1 ] );
                    keyName  = ourKey[ 0 ];
                    keyValue = ourKey[ 1 ];

                    if( exportMode === "safe" ) {
                        
                        actualKey = _prefix + '.' + keyName;

                        if( !_haskey( actualKey ) ) {
                            lds.forceset( keyName, keyValue );
                            tally++;
                        }
    
                    } else {
                        lds.forceset( keyName, keyValue );
                        tally++;
                    }
                }

                output = tally === 0
                    ? 'No keys'
                    : tally === 1
                        ? 'One key'
                        : tally + ' keys'
                ;
                console.log( output + ' imported' );
            
            } else {
                console.log( 'No keys imported: prefix does not match storage' );
            }
        }

        // boolean helper functions...
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.isarray = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'array' === _getTypeOfKey( _getPrefixedKey( key ) ) ); 
        }
        lds.isbigint = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'bigint' === _getTypeOfKey( _getPrefixedKey( key ) ) ); 
        }
        lds.isboolean = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'boolean' === _getTypeOfKey( _getPrefixedKey( key ) ) ); 
        }
        lds.iscrunch = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'compressed string' === _getTypeOfKey( _getPrefixedKey( key ) ) ); 
        }
        lds.isdate = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'date' === _getTypeOfKey( _getPrefixedKey( key ) ) ); 
        }
        lds.isfloat = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'float' === _getTypeOfKey( _getPrefixedKey( key ) ) ); 
        }
        lds.isinteger = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'integer' === _getTypeOfKey( _getPrefixedKey( key ) ) ); 
        }
        lds.isnull = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'null' === _getTypeOfKey( _getPrefixedKey( key ) ) ); 
        }
        lds.isnumber = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return (
                'float'   === _getTypeOfKey( _getPrefixedKey( key ) )
                ||
                'integer' === _getTypeOfKey( _getPrefixedKey( key ) )
            ); 
        }
        lds.isobject = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'object' === _getTypeOfKey( _getPrefixedKey( key ) ) ); 
        }
        lds.isstring = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return (
                'string'            === _getTypeOfKey( _getPrefixedKey( key ) ) 
                ||
                'compressed string' === _getTypeOfKey( _getPrefixedKey( key ) )
            ); 
        }

        // memory key boolean helper functions...
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds._isarray = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'array' === _getMemoryKeyType( key ) ); 
        }
        lds._isbigint = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'bigint' === _getMemoryKeyType( key ) ); 
        }
        lds._isboolean = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'boolean' === _getMemoryKeyType( key ) ); 
        }
        lds._iscrunch = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'compressed string' === _getMemoryKeyType( key ) ); 
        }
        lds._isdate = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'date' === _getMemoryKeyType( key ) ); 
        }
        lds._isfloat = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'float' === _getMemoryKeyType( key ) ); 
        }
        lds._isinteger = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'integer' === _getMemoryKeyType( key ) ); 
        }
        lds._isnull = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'null' === _getMemoryKeyType( key ) ); 
        }
        lds._isnumber = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return (
                'float'   === _getMemoryKeyType( key )
                ||
                'integer' === _getMemoryKeyType( key )
            ); 
        }
        lds._isobject = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return ( 'object' === _getMemoryKeyType( key ) ); 
        }
        lds._isstring = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            return (
                'string'            === _getMemoryKeyType( key ) 
                ||
                'compressed string' === _getMemoryKeyType( key )
            ); 
        }

        // returns the key at the index position (from a sorted list of keys under this prefix in this domain)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.key = function( index, keysAreSorted = false ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof index ) { throw new Error( ERROR_24 ); }

            if( index !== Number( index )    ) { throw new Error( ERROR_25 ); }
            if( index < 0 ) {                    throw new Error( ERROR_25 ); }

            let _ourKeys = _getAllKeysThisInstance()
                , _tally = _ourKeys.length
            ;

            if( keysAreSorted ) { _naturalSort( _ourKeys ); }

            if( index < _tally ) {
                return _ourKeys[ index ];
            } else {
                return undefined;
            }
        }

        // returns the memory key at the index position (from a sorted list if desired)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds._key = function( index, keysAreSorted = false ) {
            if( 'undefined' === typeof index ) { throw new Error( ERROR_24 ); }

            if( index !== Number( index )    ) { throw new Error( ERROR_25 ); }
            if( index < 0 ) {                    throw new Error( ERROR_25 ); }

            let _ourMemKeys = _getAllMemoryKeysThisInstance()
                , _tally = _ourMemKeys.length
            ;

            if( keysAreSorted ) { _naturalSort( _ourMemKeys ); }

            if( index < _tally ) {
                return _stripMemKeyPrefix( _ourMemKeys[ index ] );
            } else {
                return undefined;
            }
        }

        // returns either
        // a) total bytes of the specified key name (not its value), or
        // b) total bytes of all keys if no key specified
        // does not include key prefix
        // storage not consumption
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.keybytes = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _temp;

            if( 'undefined' === typeof key ) {
                return  _describeSize( _keyBytes() );
            } else {
                _temp = _describeSize( _keyBytes( _getPrefixedKey( key ) ) );
                return _temp !== '0 bytes' ? _temp : undefined;    
            }
        }

        // returns either
        // a) total bytes of the specified key name (not its value), or
        // b) total bytes of all keys if no key specified
        // includes key prefix
        // storage not consumption
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.keybytesall = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _temp;

            if( 'undefined' === typeof key ) {
                return  _describeSize( _keyBytesAll() );
            } else {
                _temp = _describeSize( _keyBytesAll( _getPrefixedKey( key ) ) );
                return _temp !== '0 bytes' ? _temp : undefined;    
            }
        }
    
        // returns either
        // a) total bytes of the specified key name (not its value), or
        // b) total bytes of all keys if no key specified
        // includes key prefix
        // consumption
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.keybytesmem = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _temp;

            if( 'undefined' === typeof key ) {
                return  _describeSize( _keyBytesMem() );
            } else {
                _temp = _describeSize( _keyBytesMem( _getPrefixedKey( key ) ) );
                return _temp !== '0 bytes' ? _temp : undefined;    
            }
        }



        // returns the count of keys (under this prefix in this domain)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.keys = function() {
            if( !_storageIsAvailable() ) { return false; }

            lds.length = _getAllKeysThisInstance().length;

            return lds.length;
        }
        
        lds._keys = function() {
            return _getAllMemoryKeysThisInstance().length;
        }


        // get an object showing duplicate values, their keys, and counts 
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.listdupes = function( weShouldSortThis = true ) {
            if( !_storageIsAvailable() ) { return false; }

            let _object = _getDuplicates( weShouldSortThis );

            if( _object.dupecount !== 0 ) { return _object; }

            return undefined;
        }

        // key must be of type array
        // pushes value into key at index position (default is end of key), overwriting value at index
        // destructive insert
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.poke = function( key, value, index ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key   ) { throw new Error( ERROR_11 ); }
            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }

            if( !_haskey( _getPrefixedKey( key ) ) ) { throw new Error( ERROR_15 ); }

            if( 'array' !== _getTypeOfKey( _getPrefixedKey( key ) ) ) { throw new Error( ERROR_16 ); }

            let _value      = _getTheKey( key )
                , _count    = _value.length
                , _endIndex = _count + 1
                , _label    = ''
            ;

            // set bounds if we can
            ///////////////////////
            if( 'undefined' === typeof index ) {
                index = _endIndex;

            } else
            if( 'string' === typeof index ) {
                if( index.toLowerCase() === 'start' ) {
                    index = 0;
                
                } else
                if( index.toLowerCase() === 'end' ) {
                    index = _endIndex;
                
                } else {
                    throw new Error( ERROR_26 ); 
                }

            } else
            if( 'number' === typeof index ) {
                if( index < 1 ) {
                    index = 0; 

                } else
                if( index > _count ) { 
                    index = _endIndex 

                } else 
                if( index > 0 && index < _endIndex ) {
                    // noop
                
                } else {
                    throw new Error( ERROR_27 ); 
                }

            } else {
                throw new Error( ERROR_28 ); 
            }
            ///////////////////////


            // default
            if( index === _endIndex ) {
                _value.push( value );
                _label = 'append'
            
            } else
            if( 0 === index ) {
                _value.unshift( value );
                _label = 'prepend'
            
            } else {
                _value.splice( index - 1, 1, value );
                _label = 'replace'
            }

            _label += ' value';

            let _oldValue   = _getTheKey( key )
                , _oldType  = _getTypeOfKey( _getPrefixedKey( key ) )
                , _oldValueTest = _oldType === 'bigint' ? _oldValue : JSON.stringify( _oldValue, _JSONstringer )
                , _newValue
                , _newType  = _convertToString( value )[ 1 ]
                , _newValueTest = _newType === 'bigint' ? _newValue : JSON.stringify( _newValue, _JSONstringer )
            ;

            _value = _convertToString( _value )[ 0 ];
            _writeLocalStorage( _getPrefixedKey( key ), _value );

            _newValue = _getTheKey( key );

            // trigger our "localDataStorage" event with some data, only if a new key was created or an existing key was changed
            if( _oldValueTest !== _newValueTest || _oldType !== _newType ) {
                _sendLocalDataStorageEvent( _getKeyPrefix(), 'poke', _label, key, undefined, _oldValue, _newValue, _oldType, _newType, 'disk', 'disk' );
            }
        }


        // key must be of type array
        // pulls value out of key at valindex position (default is end of key)
        // by default, when valindex is an integer it is presumed to be an index reference into the array, 
        // but when valIndexIsLiteral is TRUE then valIndex is treated as a
        // value to be searched for in the array
        // destructive delete
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.pull = function( key, valindex, valIndexIsLiteral = false ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }

            if( !_haskey( _getPrefixedKey( key ) ) ) { return undefined; }

            if( 'array' !== _getTypeOfKey( _getPrefixedKey( key ) ) ) { throw new Error( ERROR_16 ); }

            let _value                 = _getTheKey( key )
                , _count               = _value.length
                , _endIndex            = _count + 1
                , _label               = ''
                , _valueFound          = 0
                , valIndexIsNotLiteral = !valIndexIsLiteral
            ;

            // set bounds if we can
            ///////////////////////
            if( 'undefined' === typeof valindex ) {
                valindex = _endIndex;

            } else
            if( 'string' === typeof valindex ) {
                if( valindex.toLowerCase() === 'start' ) {
                    valindex = 0;
                
                } else
                if( valindex.toLowerCase() === 'end' ) {
                    valindex = _endIndex;

                } else 
                if( valindex !== '' ) {
                    // noop
                
                } else {
                    throw new Error( ERROR_26 ); 
                }

            } else
            if( 'number' === typeof valindex ) {

                if( valIndexIsNotLiteral ) {
                   if( valindex < 2 ) {
                        valindex = 0; 

                    } else
                    if( valindex > _count ) { 
                        valindex = _endIndex 

                    } else 
                    if( valindex > 0 && valindex < _endIndex ) {
                        // noop
                    
                    } else {
                        throw new Error( ERROR_27 ); 
                    }

                } 

            } else 
            if( 'bigint' === typeof valindex ) {
                // noop

            } else
            if( 'number'  === typeof valindex ) {
                // noop

            } else
            if( 'boolean' === typeof valindex ) {
                // noop

            } else
            if( 'object'  === typeof valindex ) {
                // noop

            } else {
                throw new Error( ERROR_28 ); 
            }
            ///////////////////////


            if( valIndexIsNotLiteral && valindex === _endIndex ) {
                _value.pop();
                _label = 'from end';
            
            } else
            if( valIndexIsNotLiteral && 0 === valindex ) {
                _value.shift();
                _label = 'from start';
            
            } else
            if( valIndexIsNotLiteral && 'number' === typeof valindex ) {
                _value.splice( valindex - 1, 1 );
                _label = 'from contents';
            
            } else {
                for( let i = 0; i < _value.length; i++ ) {
                    if( JSON.stringify( _value[ i ], _JSONstringer ) === JSON.stringify( valindex, _JSONstringer ) ) {
                        _valueFound = i + 1;
                        break;
                    }
                }

                if( _valueFound ) {
                    _value.splice( _valueFound - 1, 1 );
                } else {
                    return undefined;
                }

                _label = 'from contents'
            }

            let _oldValue       = _getTheKey( key )
                , _oldType      = _getTypeOfKey( _getPrefixedKey( key ) )
                , _oldValueTest = _oldType === 'bigint' ? _oldValue : JSON.stringify( _oldValue, _JSONstringer )
                , _newValue
                , _newType      = undefined //_convertToString( value )[ 1 ]
                , _newValueTest = _newType === 'bigint' ? _newValue : JSON.stringify( _newValue, _JSONstringer )
            ;

            _value = _convertToString( _value )[ 0 ];
            _writeLocalStorage( _getPrefixedKey( key ), _value );

            _newValue = _getTheKey( key );

            if( _oldValueTest !== _newValueTest || _oldType !== _newType ) {
                if( JSON.stringify( _oldValue, _JSONstringer ) !== JSON.stringify( _newValue, _JSONstringer ) ) {
                    _sendLocalDataStorageEvent( _getKeyPrefix(), 'pull', 'remove value ' + _label, key, undefined, _oldValue, _newValue, _oldType, _newType, 'disk', 'disk' );
                }
            }
        }


        // key must be of type array
        // pulls every occurrence of value out of key
        // destructive delete
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.pullall = function( key, arrayItem ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key       ) { throw new Error( ERROR_11 ); }
            if( 'undefined' === typeof arrayItem ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( arrayItem ) ) { throw new Error( ERROR_13 ); }

            if( !_haskey( _getPrefixedKey( key ) ) ) { return undefined; }

            if( 'array' !== _getTypeOfKey( _getPrefixedKey( key ) ) ) { throw new Error( ERROR_16 ); }

            let _value = _getTheKey( key );

            const removeItem = function( array, item ) {
                    let i = array.length;

                    while( i-- ) {
                        if( array[ i ] === item ) {
                            array.splice( array.indexOf( item ), 1 );
                        }
                    }
                }
            ;

            removeItem( _value, arrayItem );

            let _oldValue       = _getTheKey( key )
                , _oldType      = _getTypeOfKey( _getPrefixedKey( key ) )
                , _oldValueTest = _oldType === 'bigint' ? _oldValue : JSON.stringify( _oldValue, _JSONstringer )
                , _newValue
                , _newType      = undefined //_convertToString( value )[ 1 ]
                , _newValueTest = _newType === 'bigint' ? _newValue : JSON.stringify( _newValue, _JSONstringer )
            ;

            _value = _convertToString( _value )[ 0 ];
            _writeLocalStorage( _getPrefixedKey( key ), _value );

            _newValue = _getTheKey( key );

            if( _oldValueTest !== _newValueTest || _oldType !== _newType ) {
                if( JSON.stringify( _oldValue, _JSONstringer ) !== JSON.stringify( _newValue, _JSONstringer ) ) {
                    _sendLocalDataStorageEvent( _getKeyPrefix(), 'pullall', 'remove all values from contents', key, undefined, _oldValue, _newValue, _oldType, _newType, 'disk', 'disk' );
                }
            }
        }


        // key must be of type array
        // pushes value into key at index position (default is end of key)
        // if key does not exist, creates new key of type array with data
        // non-destructive insert
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.push = function( key, value, index ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key   ) { throw new Error( ERROR_11 ); }
            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }

            //if( !_haskey( _getPrefixedKey( key ) ) ) { throw new Error( ERROR_15 ); }

            if( _haskey( _getPrefixedKey( key ) ) && 'array' !== _getTypeOfKey( _getPrefixedKey( key ) ) ) { throw new Error( ERROR_16 ); }

            // if key does not exist, create it
            if( !_haskey( _getPrefixedKey( key ) ) ) {

                let inval = new Array()
                    , _vals = arguments.length
                ;

                // more than 1 value
                if( _vals > 2 ) {
                    for( let i = 1; i < _vals; i++ ) {
                        if( _getTypeOf( arguments[ i ] ) === 'array' ) {
                            inval = inval.concat( arguments[ i ] );
                        } else {       
                            inval.push( arguments[ i ] );
                        }
                    }

                    value = inval;

                // only 1 value (check if it's not an array)
                } else
                if( _getTypeOf( value ) !== 'array' ) {

                    for( let i = 1; i < _vals; i++ ) {
                        inval.push( arguments[ i ] );
                    }

                    value = inval;
                }

                let _oldValue   = _getTheKey( key )
                    , _oldType  = _getTypeOfKey( _getPrefixedKey( key ) )
                    , _oldValueTest = _oldType === 'bigint' ? _oldValue : JSON.stringify( _oldValue, _JSONstringer )
                    , _newValue = value
                    , _newType  = _convertToString( value )[ 1 ]
                    , _newValueTest = _newType === 'bigint' ? _newValue : JSON.stringify( _newValue, _JSONstringer )
                ;

                value = _convertToString( value )[ 0 ];
                _writeLocalStorage( _getPrefixedKey( key ), value );

                _sendLocalDataStorageEvent( _getKeyPrefix(), 'push', 'create new key', undefined, key, _oldValue, _newValue, _oldType, _newType, 'disk', 'disk' );

                lds.length += 1;
                _updateLengthProp();


            // the key exists
            } else {

                let _value = _getTheKey( key )
                    , _count = _value.length
                    , _endIndex = _count + 1
                    , _label = ''
                ;

                // set bounds if we can
                ///////////////////////
                if( 'undefined' === typeof index ) {
                    index = _endIndex;

                } else
                if( 'string' === typeof index ) {
                    if( index.toLowerCase() === 'start' ) {
                        index = 0;
                    
                    } else
                    if( index.toLowerCase() === 'end' ) {
                        index = _endIndex;
                    
                    } else {
                        throw new Error( ERROR_26 ); 
                    }

                } else
                if( 'number' === typeof index ) {
                    if( index < 2 ) {
                        index = 0; 

                    } else
                    if( index > _count ) { 
                        index = _endIndex 

                    } else 
                    if( index > 0 && index < _endIndex ) {
                        // noop
                    
                    } else {
                        throw new Error( ERROR_27 ); 
                    }

                } else {
                    throw new Error( ERROR_28 ); 
                }
                ///////////////////////


                // default
                if( index === _endIndex ) {
                    _value.push( value );
                    _label = 'append'
                
                } else
                if( 0 === index ) {
                    _value.unshift( value );
                    _label = 'prepend'
                
                } else {
                    _value.splice( index - 1, 0, value );
                    _label = 'insert'
                }

                _label += ' value';


                let _oldValue   = _getTheKey( key )
                    , _oldType  = _getTypeOfKey( _getPrefixedKey( key ) )
                    , _oldValueTest = _oldType === 'bigint' ? _oldValue : JSON.stringify( _oldValue, _JSONstringer )
                    , _newValue
                    , _newType  = _convertToString( value )[ 1 ]
                    , _newValueTest = _newType === 'bigint' ? _newValue : JSON.stringify( _newValue, _JSONstringer )
                ;

                _value = _convertToString( _value )[ 0 ];
                _writeLocalStorage( _getPrefixedKey( key ), _value );

                _newValue = _getTheKey( key );

                if( _oldValueTest !== _newValueTest || _oldType !== _newType ) {
                    _sendLocalDataStorageEvent( _getKeyPrefix(), 'push', _label, key, undefined, _oldValue, _newValue, _oldType, _newType, 'disk', 'disk' );
                }
            }
        }

        // deletes an existing key
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.remove = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }

            let _oldValue  = _getTheKey( key )
                , _oldType = _getTypeOfKey( _getPrefixedKey( key ) )
            ;

            if( _haskey( _getPrefixedKey( key ) ) ) {
                _deleteLocalStorage( _getPrefixedKey( key ) );

                _sendLocalDataStorageEvent( _getKeyPrefix(), 'remove', 'remove key', key, undefined, _oldValue, undefined, _oldType, undefined, 'disk', 'disk' );
                
                lds.length -= 1;
                _updateLengthProp();

                return _weAreVerbose ? 'key removed' : undefined;

            } else {
                return undefined;
            }
        }

        lds._remove = function( key ) {
            Reflect.deleteProperty( lds, _memoryKeyPrefix + key );
        }

        // rename a key
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.rename = function( key, newKey ) {
            if( !_storageIsAvailable() ) { return false; }

            if( typeof key    === 'undefined'        ) { throw new Error( ERROR_11 );  }
            if( !_haskey( _getPrefixedKey( key ) )   ) { throw new Error( ERROR_15 );  }
            if( typeof newKey === 'undefined'        ) { throw new Error( ERROR_29 ); }
            if( key === newKey                       ) { throw new Error( ERROR_30 ); }
            if( _haskey( _getPrefixedKey( newKey ) ) ) { throw new Error( ERROR_31 ); }

            let _oldValue   = _getTheKey( key )
                , _oldType  = _getTypeOfKey( _getPrefixedKey( key ) )
                , _newValue = _convertToString( _oldValue )[ 0 ]
            ;

            _deleteLocalStorage( _getPrefixedKey( key ) );
            _writeLocalStorage( _getPrefixedKey( newKey ), _newValue );

            _sendLocalDataStorageEvent( _getKeyPrefix(), 'rename', 'key name change', key, newKey, _oldValue, _oldValue, _oldType, _oldType, 'disk', 'disk' );

            // no change in lds.length
        }

        // transfer key data from local storage to memory
        // this is a transfer, not a sync
        // the destination key is created (or overwritten) and the source key is deleted 
        lds._restore = function( key, weOverwriteExistingKey ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }

            // check if local storage key exists
            if( !_haskey( _getPrefixedKey( key ) ) ) { throw new Error ( ERROR_43 ); }

            // get the disk key value and type 
            let diskKeyValue  = _getTheKey( key )
                , diskKeyType = _getTypeOfKey( _getPrefixedKey( key ) )
                , newMemKeyValue = ''
                , newMemKeyType  = ''
                , oldMemKeyValue = ''
                , oldMemKeyType  = ''
            ;

            // check if this memory key exists
            if( lds._haskey( key ) ) {
                if( weOverwriteExistingKey ) {

                    oldMemKeyValue = lds._get( key );
                    oldMemKeyType  = lds._showtype( key );

                    // write the local storage key to memory
                    lds._set( key, diskKeyValue );

                    newMemKeyValue = lds._get( key );
                    newMemKeyType  = lds._showtype( key );

                    // verify backup
                    if( _valuesAreEqual( diskKeyValue, newMemKeyValue ) && diskKeyType === newMemKeyType ) {
                        
                        // delete localStorage key
                        _deleteLocalStorage( _getPrefixedKey( key ) );

                        _sendLocalDataStorageEvent( _getKeyPrefix(), 'restore', 'key value change', key, key, oldMemKeyValue, newMemKeyValue, oldMemKeyType, newMemKeyType, 'disk', 'memory' );

                        if( _weAreVerbose ) { return "Existing Memory Key has been overwritten from localStorage and the value verified"; }

                    } else {
                        throw new Error ( ERROR_47 );
                    }

                } else {
                    throw new Error( ERROR_41 );
                }

            } else {
                // write the local storage key to memory
                lds._set( key, diskKeyValue );

                newMemKeyValue = lds._get( key );
                newMemKeyType  = lds._showtype( key );

                // verify backup
                if( _valuesAreEqual( diskKeyValue, newMemKeyValue ) && diskKeyType === newMemKeyType ) {
                    _deleteLocalStorage( _getPrefixedKey( key ) );

                    _sendLocalDataStorageEvent( _getKeyPrefix(), 'restore', 'create new key', undefined, key, undefined, newMemKeyValue, undefined, newMemKeyType, 'disk', 'memory' );

                    if( _weAreVerbose ) { return "New Memory Key created from localStorage (value verified)"; }

                } else {
                    throw new Error ( ERROR_48 );
                }
            }
        }

        // gets value of obfuscated key
        // fails silently returning undefined if key does not exist
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.safeget = function( key, userScrambleKey ) {
            if( !_storageIsAvailable() ) { return false; }

            let value;

            if( _haskey( _getPrefixedKey( key ) ) ) {
                value = _readLocalStorage( _getPrefixedKey( key ) );

                if( value.substr( 0, 1 ) !== TYPE_OBFUSCATE ) { throw new Error( ERROR_39 ); }

                value = value.substr( 1 );

                if( 'undefined' === typeof userScrambleKey ) {
                    value = _xorString(       value, _scrambleKey, key );
                    value = _unshuffleString( value, _scrambleKey, key );

                } else {
                    value = _xorString(       value, userScrambleKey, key );
                    value = _unshuffleString( value, userScrambleKey, key );
                }

                value = _convertFromString( value );
                return value;

            } else {
                return undefined;
            }
        }

        /*
        lds._safeget = function( key, userScrambleKey ) {
            let value = _readMemoryKey( key );

            if( typeof value === 'undefined' ) { return undefined; }

            if( value.substr( 0, 1 ) !== TYPE_OBFUSCATE ) { throw new Error( ERROR_39 ); }

            value = value.substr( 1 );

            if( 'undefined' === typeof userScrambleKey ) {
                value = _xorString(       value, _scrambleKey, key );
                value = _unshuffleString( value, _scrambleKey, key );

            } else {
                value = _xorString(       value, userScrambleKey, key );
                value = _unshuffleString( value, userScrambleKey, key );
            }

            return _convertFromString( value );
        }
        */

        // sets key to value, respecting the type and obfuscating the value
        // the key name itself is used as part of the obfucation logic, thus
        // if a scrambled key is renamed, its scramble key will no longer work
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.safeset = function( key, value, userScrambleKey ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key   ) { throw new Error( ERROR_11 ); }
            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }

            let _scrambleType   = ''
                , _temp         = _readLocalStorage( _getPrefixedKey( key ) )
                , _oldValue     = ( _temp === null ? undefined : _temp ) 
                , _oldType      = _getTypeOfKey( _getPrefixedKey( key ) )
                , _oldValueTest = _oldType === 'bigint' ? _oldValue : JSON.stringify( _oldValue, _JSONstringer )
                , _newValue     = ''
                , _newType      = 'obfuscated key'
                , _newValueTest = _newType === 'bigint' ? _newValue : JSON.stringify( _newValue, _JSONstringer )
            ;

            value = _convertToString( value )[ 0 ];

            if( 'undefined' === typeof userScrambleKey ) {
                value = _shuffleString( value, _scrambleKey, key );
                value = _xorString(     value, _scrambleKey, key );

                _scrambleType = ' with global scramble key';

            } else {
                value = _shuffleString( value, userScrambleKey, key );
                value = _xorString(     value, userScrambleKey, key );

                _scrambleType = ' with user scramble key';
            }

            value = TYPE_OBFUSCATE + value;

            _writeLocalStorage( _getPrefixedKey( key ), value );    

            _newValue = _readLocalStorage( _getPrefixedKey( key ) );


            if( _oldValueTest !== _newValueTest || _oldType !== _newType ) {
                if( 'undefined' === typeof _oldValue ) {
                    _sendLocalDataStorageEvent( _getKeyPrefix(), 'safeset', 'create new key' + _scrambleType, undefined, key, _oldValue, _newValue, _oldType, _newType, 'disk', 'disk' );

                    lds.length += 1;
                    _updateLengthProp();


                    if( _weAreVerbose ) { return "New obfuscated key created" + _scrambleType; }

                } else {
                    if( _oldValue !== _newValue ) {
                        _sendLocalDataStorageEvent( _getKeyPrefix(), 'safeset', 'key value change' + _scrambleType, key, undefined, _oldValue, _newValue, _oldType, _newType, 'disk', 'disk' );
    
                        if( _weAreVerbose ) { return "Existing key has been overwritten with obfuscated value created" + _scrambleType; }
                    }
                }
            }
        }

        /*
        lds._safeset = function( key, value, userScrambleKey ) {
            if( 'undefined' === typeof key   ) { throw new Error( ERROR_11 ); }
            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }

            value = _convertToString( value )[ 0 ];

            if( 'undefined' === typeof userScrambleKey ) {
                value = _shuffleString( value, _scrambleKey, key );
                value = _xorString(     value, _scrambleKey, key );

            } else {
                value = _shuffleString( value, userScrambleKey, key );
                value = _xorString(     value, userScrambleKey, key );
            }

            value = TYPE_OBFUSCATE + value;

            _readMemoryKey( key ) = value;
        }
        */

        // sets key to value, respecting the data type
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.set = function( key, value ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key   ) { throw new Error( ERROR_11 ); }
            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }

            let _oldValue       = _getTheKey( key )
                , _oldType      = _getTypeOfKey( _getPrefixedKey( key ) )
                , _oldValueTest = _oldType === 'bigint' ? _oldValue : JSON.stringify( _oldValue, _JSONstringer )
                , _newValue     = value
                , _newType      = _convertToString( value )[ 1 ]
                , _newValueTest = _newType === 'bigint' ? _newValue : JSON.stringify( _newValue, _JSONstringer )
            ;

            value = _convertToString( value )[ 0 ];
            _writeLocalStorage( _getPrefixedKey( key ), value );

            if( _oldValueTest !== _newValueTest || _oldType !== _newType ) {
                if( 'undefined' === typeof _oldValue ) {
                    _sendLocalDataStorageEvent( _getKeyPrefix(), 'set', 'create new key', undefined, key, _oldValue, _newValue, _oldType, _newType, 'disk', 'disk' );

                    lds.length += 1;
                    _updateLengthProp();
        
                    if( _weAreVerbose ) { return "New " + _newType + " key created"; }

                } else {
                    _sendLocalDataStorageEvent( _getKeyPrefix(), 'set', 'key value change', key, undefined, _oldValue, _newValue, _oldType, _newType, 'disk', 'disk' );

                    if( _weAreVerbose ) { return "Existing key has been overwritten"; }
                }
            }
        }

        lds._set = function( key, value ) {
            if( 'undefined' === typeof key   ) { throw new Error( ERROR_11 ); }
            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }

            // if the value is a string let's see if we can compress it
            if( typeof value === 'string' ) { value = _convertToString( value )[ 0 ]; }

            //lds[ _memoryKeyPrefix + key ] = value;
            Reflect.set( lds, _memoryKeyPrefix + key, value );
        }

        // set the "global" scramble key
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.setscramblekey = function( _newscrambleKey ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof _newscrambleKey ) { throw new Error( ERROR_14 ); }
            if( _valueIsIllegalType( _newscrambleKey ) ) { throw new Error( ERROR_13 ); }

            _scrambleKey = _newscrambleKey;

            if( _weAreVerbose ) { return "The new global scramble key is set"; }
        }

        // returns an array of duplicate key values, if any
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.showdupes = function( weShouldSortThis = true ) {
            if( !_storageIsAvailable() ) { return false; }

            let _tempArray = _showDupes();

            if( weShouldSortThis ) { _naturalSort( _tempArray ); }

            if( _tempArray.length ) { return _tempArray; }

            return _weAreVerbose ? "No duplicate values in storage" : undefined;
        }

        // show all keys having value
        // return array of values, sorted alphabetically (optional)
        // left unsorted, keys are examined in the order found in the store 
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.showkeys = function( value, weShouldStripKeyPrefix = true, weShouldSortThis = true ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }

            let _tempVal     = ''
                , _tempArray = new Array()
                , _tempKeys  = _getAllKeysThisInstance()  // get prefixed keys
                , _len       = _tempKeys.length
                , _key
            ;

            for( let i = _len; i--; ) {
                _key = _tempKeys[ i ];
                _tempVal = _get( _key );
                
                if( JSON.stringify( _tempVal, _JSONstringer ) === JSON.stringify( value, _JSONstringer ) ) {
                    if( weShouldStripKeyPrefix ) {  
                        _key = _stripPrefix( _key );
                    }

                    _tempArray.push( _key );
                }
            }

            if( weShouldSortThis ) { _naturalSort( _tempArray ); }

            if( _tempArray.length ) { return _tempArray; }

            return _weAreVerbose ? "No keys have that value" : undefined;
        }                   

        // show all keys having type of value
        // return array of values, sorted alphabetically (optional)
        // left unsorted, keys are examined in the order found in the store 
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.showkeytypes = function( type, weShouldStripKeyPrefix = true, weShouldSortThis = true ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof type                     ) { throw new Error( ERROR_18 ); }

            if( "symbol" === type.toLowerCase()                 ) { throw new Error( ERROR_13 ); }

            if( !SUPPORTED_TYPES.includes( type.toLowerCase() ) ) { throw new Error( ERROR_17 ); }

            type = type.toLowerCase();

            let _tempType    = ''
                , _tempArray = new Array()
                , _tempKeys  = _getAllKeysThisInstance()
                , _len       = _tempKeys.length
                , _key
            ;

            for( let i = _len; i--; ) {
                _key = _tempKeys[ i ];
                _tempType = _getTypeOfKey( _key );
                
                if(
                    ( type === "number"  && ( _tempType === "float" || _tempType === "integer" ) )
                    ||
                    ( type !== "number"  &&   _tempType === type )
                ){

                    if( weShouldStripKeyPrefix ) {  
                        _key = _stripPrefix( _key );
                    }                        

                    _tempArray.push( _key );
                }
            }

            if( weShouldSortThis ) { _naturalSort( _tempArray ); }

            if( _tempArray.length ) { return _tempArray; }

            return _weAreVerbose ? "No keys are of that type" : undefined;
        }                   

        // returns the full internal prefix used for all keys
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.showprefix = function() {
            if( !_storageIsAvailable() ) { return false; }

            return _weAreVerbose
                ? "The key prefix (" + _prefix + ".) adds " + _keyNameOverhead + " to each key name (stored using " + _keyNameOverhead2 + ")"
                : _prefix + '.'
            ;
        }

        // measure localStorage size
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.showquota = function() {
            if( !_storageIsAvailable() ) { return false; }

            const _qbytes = _quota();

            // set the quota property
            lds.quota = _describeSize( _qbytes, true );

            return _weAreVerbose
                ? 'Total storage allocated is ' + _describeSize( _qbytes, true ) + ' (consuming ' + _describeSize( _qbytes * 2, true ) + ' of memory)'
                : _describeSize( _qbytes, true )
        }

        // calculate the amount of bytes used for all keys in the store under this domain (key name and key value) ignoring prefix
        // this is not memory storage requirements (not UCS-2_, it is current bytes used
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.showquotaused = function( outputIsJSON = false ) {
            if( !_storageIsAvailable() ) { return false; }

            let allStrings = ''
                , _keyName
                , _keyVal
                , _len = localStorage.length
                , _qbytes
            ;

            if( localStorage.length !== 0 ) {
                // loop through all localStorage keys and get the keyname and keyvalue
                for( let i = _len; i--; ) {
                    _keyName    = localStorage.key( i );
                    _keyVal     = _readLocalStorage( _keyName );
                    allStrings += ( _keyName + _keyVal );
                }

                _qbytes = _getByteCount( allStrings );

                if( outputIsJSON ) {
                    return _qbytes;

                } else {

                    return _weAreVerbose
                        ? 'Total storage used is ' + _describeSize( _qbytes ) + ' (consuming ' + _describeSize( _qbytes * 2, true ) + ' of memory)'
                        : _describeSize( _qbytes )
                }

            } else {
                return _describeSize( 0 );
            }
        } 

        // returns data type of key value
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.showtype = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _returnedValue;

            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }
            
            _returnedValue = _getTypeOfKey( _getPrefixedKey( key ) ); 

            if( _weAreVerbose ) {
                if( 'undefined' === typeof _returnedValue ) {
                    return "Key does not exist and cannot be checked";
                
                } else {
                    if( "array" === _returnedValue ) {
                        return "This key is an Array Key";
                    } else {
                        return "Key has value whose data type is " + _returnedValue;
                    }
                }

            } else {
                return _returnedValue; 
            }
        }

        // returns data type of memory key value
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds._showtype = function( key ) {
            if( 'undefined' === typeof key ) { throw new Error( ERROR_11 ); }

            let _returnedValue = ''
                , value = _readMemoryKey( key )
            ;
            
            _returnedValue = _getTypeOfMemoryKey( value ); 

            return _returnedValue; 
        }



        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.shufflestring = function( _string, _keySeed, _keyName ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof _string  ) { throw new Error( ERROR_32 ); }
            if( 'undefined' === typeof _keySeed ) { throw new Error( ERROR_10 ); }
            if( 'undefined' === typeof _keyName ) { throw new Error( ERROR_11 ); }

            return _shuffleString( _string, _keySeed, _keyName );
        }

        // returns count of codepoints in key's value (not length, not byte count, not grapheme count)
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.size = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _returnedValue = _getTheKey( key );
            
            if( 'undefined' !== typeof _returnedValue ) {
                _returnedValue = _getCodePointCount( _returnedValue );
            }

            if( _weAreVerbose ) {
                if( 'undefined' === typeof _returnedValue ) {
                    return "Key does not exist and cannot be checked";
                
                } else {
                    return "Key value has " + _returnedValue + " codepoints";
                }

            } else {
                return _returnedValue; 
            }
        }

        // sets key to value, respecting the data type; will not overwrite an existing key
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.softset = function( key, value ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key   ) { throw new Error( ERROR_11 ); }
            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }

            let  _newType   = _convertToString( value )[ 1 ]
                , _newValue = value
                , _returnLabel
            ;

            // create new key
            if( !_haskey( _getPrefixedKey( key ) ) ) {
                value = _convertToString( value )[ 0 ];
                _writeLocalStorage( _getPrefixedKey( key ), value );

                _sendLocalDataStorageEvent( _getKeyPrefix(), 'softset', 'create new key', undefined, key, undefined, _newValue, undefined, _newType, 'disk', 'disk' );
            
                lds.length += 1;
                _updateLengthProp();

                _returnLabel = "array" === _newType 
                    ? "New Array Key created" 
                    : "New " + _newType + " key created";

                return ( _weAreVerbose === 1 ? _returnLabel : undefined );

            } else {
                return ( _weAreVerbose === 1 ? "Key already exists and cannot be overwritten" : undefined );
            }
        }

        // show the kay-value pairs held in memory
        lds._store = function( keysAreSorted = false ) {
            let memKeys = _getAllMemoryKeysThisInstance( STRIP_THE_PREFIX )
                , keyCount = memKeys.length
                , ourMemKeys = new Array()
                , thisMemKeyName
                , thisMemKeyValue
            ;

            if( keysAreSorted ) { _naturalSort( memKeys ); }

            for( let i = 0; i < keyCount; i++ ) {
                thisMemKeyName  = memKeys[ i ];
                thisMemKeyValue = Reflect.get( lds, _memoryKeyPrefix + thisMemKeyName );
                ourMemKeys.push( [ thisMemKeyName, thisMemKeyValue ] );
            }

            return ourMemKeys.length === 0 ? undefined : ourMemKeys; 
        }

        // returns decompressed text
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.uncrunch = function( _crunchedText ) {
            if( !_storageIsAvailable() ) { return false; }

            return _uncrunch( _crunchedText );
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.unshufflestring = function( _string, _keySeed, _keyName ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof _string  ) { throw new Error( ERROR_32 ); }
            if( 'undefined' === typeof _keySeed ) { throw new Error( ERROR_10 ); }
            if( 'undefined' === typeof _keyName ) { throw new Error( ERROR_11 ); }

            return _unshuffleString( _string, _keySeed, _keyName );
        }

        // get total bytes of the specified key's value, or total bytes of all key values if no key specified
        // storage requirements for the embedded flags are not considered, just the raw data
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.valbytes = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _temp;

            if( 'undefined' === typeof key ) {
                return _describeSize( _valBytes() );
            } else {
                _temp = _describeSize( _valBytes( _getPrefixedKey( key ) ) );
                return _temp !== '0 bytes' ? _temp : undefined;    
            }
        }

        // get total bytes of the specified key's value, or total bytes of all key values if no key specified
        // storage requirements for the embedded flags are calculated
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.valbytesall = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _temp;

            if( 'undefined' === typeof key ) {
                return _describeSize( _valBytesAll() );
            } else {
                _temp = _describeSize( _valBytesAll( _getPrefixedKey( key ) ) );
                return _temp !== '0 bytes' ? _temp : undefined;    
            }
        }

        // get total bytes of the specified key's value, or total bytes of all key values if no key specified
        // storage requirements for the embedded flags are calculated
        // this is memory consumption, not storage
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.valbytesmem = function( key ) {
            if( !_storageIsAvailable() ) { return false; }

            let _temp;

            if( 'undefined' === typeof key ) {
                return _describeSize( _valBytesMem() );
            } else {
                _temp = _describeSize( _valBytesMem( _getPrefixedKey( key ) ) );
                return _temp !== '0 bytes' ? _temp : undefined;    
            }
        }

        // set or qoery the feedback mode
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.verbosity = function( value ) {
            if( !_storageIsAvailable() ) { return false; }

            value = Boolean( value );

            if( 'undefined' !== typeof value ) {
                _setVerbosity( value );
            }

            return "Verbosity is " + ( _weAreVerbose ? "on" : "off" );
        }

        // checks whether key (which must be of type array) contains value, and returns index
        // ex. string search for value 'english' in education key [ 'math', 'english', 'science' ]
        // ex. object search for value {'book':'math'} in education key [ {'book':'math'}, {'book':'english'}, {'book':'science'} ]
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.where = function( key, value ) {
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof key   ) { throw new Error( ERROR_11 ); }
            if( 'undefined' === typeof value ) { throw new Error( ERROR_12 ); }
            if( _valueIsIllegalType( value ) ) { throw new Error( ERROR_13 ); }

            if( !_haskey( _getPrefixedKey( key ) ) ) { return undefined; }

            if( 'array' !== _getTypeOfKey( _getPrefixedKey( key ) ) ) { throw new Error( ERROR_16 ); }

            let _valueFound = false
                , _value = _getTheKey( key );
            ;

            for( let i = 0; i < _value.length; i++ ) {
                if( JSON.stringify( _value[ i ], _JSONstringer ) === JSON.stringify( value, _JSONstringer ) ) {
                    _valueFound = i + 1;
                    break;
                }
            }

            return _weAreVerbose ? 'Value was found in the Array Key at position ' + _valueFound : _valueFound;
        }

        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        lds.xorstring = function( _string, _keySeed, _keyName ) { 
            if( !_storageIsAvailable() ) { return false; }

            if( 'undefined' === typeof _string  ) { throw new Error( ERROR_32 ); }
            if( 'undefined' === typeof _keySeed ) { throw new Error( ERROR_10 ); }
            if( 'undefined' === typeof _keyName ) { throw new Error( ERROR_11 ); }

            return _xorString( _string, _keySeed, _keyName );
        } 


        /////////////////////////////////////////////////////////
        /////////////////////////////////////////////////////////


        try{
            // if localStorage is available in the browser
            // run housekeeping tasks and return the object
            // (when localStorage is not enabled then getting this property will fail)
            let x = localStorage.length;

            // identity
            lds.version = 'localDataStorage ' + VERSION;

            // mock the length property similar to localStorage
            Object.defineProperty( lds, 'length', {
                enumerable     : false
                , configurable : false
                , writable     : true
                , value        : _getAllKeysThisInstance().length
            });
            
            let _keyNameOverhead    = _describeSize( _getByteCount( lds.showprefix() )     )
                , _keyNameOverhead2 = _describeSize( _getByteCount( lds.showprefix() ) * 2 )
            ;

            (function() {
                // set the quota property
                lds.quota = lds.showquota();

                // initialization checks and feedback
                let _priorKeysExist = false
                    , _key
                    , _randomPrefix = false
                    , _len = localStorage.length
                    , _test
                    , _thePrefix = lds.showprefix()
                ;

                const _interfaceTestsGood =
                    function() {
                        let _return = false;
                        lds.safeset( STORAGE_TEST, STORAGE_TEST, STORAGE_TEST );
                        if( STORAGE_TEST === lds.safeget( STORAGE_TEST, STORAGE_TEST ) ) { _return = true; }
                        lds.remove( STORAGE_TEST );
                        return _return;
                    }
                ;

                if( _storageIsAvailable() ) {

                    if( 'undefined' === typeof _storageKeyPrefix && !( _userswitches && _userswitches.includes( '/q' ) ) ) {
                        _randomPrefix = true;
                        console.info( 'No prefix specified. Creating a %crandom %cprefix --> %c' + _thePrefix, 'font-style: italic;', 'font-style: normal;', 'font-weight: bold;' );
                    }

                    if( '' === _storageKeyPrefix &&                 !( _userswitches && _userswitches.indexOf( '/q' ) !== -1 ) ) {
                        console.info( 'Empty prefix given (%c' + _thePrefix + '%c), but a usable prefix is %cstrongly recommended%c to organize keys!', 'font-weight: bold;', 'font-style: normal;', 'text-decoration: underline;', 'text-decoration: none;' );
                    }
            
                    if(                                             !( _userswitches && _userswitches.indexOf( '/q' ) !== -1 ) ) {
                        console.log( '💼 localDataStorage instantiated. ' + ( _randomPrefix === true ? 'The random prefix' : 'Your specified prefix' ) + ' (%c' + _thePrefix + '%c) adds ' + _keyNameOverhead + ' to every key name (stored using ' + _keyNameOverhead2 + ').', 'font-weight: bold;', 'font-style: normal;' );
                    }

                    if( _userswitches && _userswitches.includes( '/w' ) ) { 
                        for( let i = _len; i--; ) {
                            _key = localStorage.key( i );
                            if( _key.indexOf( _thePrefix ) !== -1 ) {
                                _priorKeysExist = true;
                                break;
                            } 
                        }
                        if( _priorKeysExist ) {
                            console.warn( '%cAttention! %cKeys with this prefix already exist in localStorage for this domain!', 'color: rgb(230,0,0); font-weight: bold;', 'color: rgb(230,0,0);' );
                        }
                    }
                    
                    if( _userswitches && _userswitches.includes( '/t' ) ) {
                        if( _interfaceTestsGood() ) {
                            console.log( 'Tested good: The localStorage API is available' );
                        }
                    }

                } else {
                    ourAPIChannel.close();
                    console.warn( '%cWarning! Cannot access localStorage! %cBailing out...', 'color: rgb(230,0,0); font-weight: bold;', 'color: rgb(230,0,0);' );
                }

            })();

            return lds;

        // if localStorage is disabled in the browser
        // do nothing and output the error
        } catch( e ) {
            ourAPIChannel.close();
            console.error( '%cFatal error! %cThe localStorage API appears to be disabled! Please check your browser’s settings for cookies and storage.', 'color: rgb(230,0,0); font-weight: bold;', 'color: rgb(230,0,0);' );
        }

    })( _specifiedPrefix, _switches );
};
